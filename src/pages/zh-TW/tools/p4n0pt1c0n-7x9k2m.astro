---
import BaseLayout from '../../../layouts/BaseLayout.astro';

// Type definitions (kept for reference, data loaded client-side now)
// Data is now fetched from azure_container API at runtime
// See: Cockpit/ideas/panopticon-db-architecture-plan.md (Phase 4)

// Empty initial state - data loaded via client-side fetch
const data = null;
const xData = null;
---

<BaseLayout
  title="Content Discovery"
  description="Personal content discovery tool"
  noindex={true}
  hideLanguageSwitcher={true}
>
  <div class="max-w-5xl mx-auto px-4 py-8">
    <!-- Header -->
    <div class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-2xl font-bold text-ink-900 mb-1">Content Discovery</h1>
        <p class="text-ink-500" id="date-display">
          {data ? data.date : 'Loading...'}
        </p>
      </div>
      <button
        id="refresh-btn"
        type="button"
        class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors flex items-center gap-2"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
        Refresh
      </button>
    </div>

    <!-- Source Tabs (clickable stats) -->
    <div id="source-tabs" class="flex gap-2 mb-4 overflow-x-auto pb-2">
      <button data-source="all" class="source-tab active flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-accent text-white">
        All <span class="ml-1 opacity-80">{data?.stats.total_items || 0}</span>
      </button>
      <button data-source="x" class="source-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-sky-50 text-sky-700 hover:bg-sky-100">
        ğ• <span class="ml-1 opacity-70">{xData?.stats.total_items || 0}</span>
      </button>
      <button data-source="reddit" class="source-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-orange-50 text-orange-700 hover:bg-orange-100">
        Reddit <span class="ml-1 opacity-70">{data?.stats.reddit_posts || 0}</span>
      </button>
      <button data-source="hackernews" class="source-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-amber-50 text-amber-700 hover:bg-amber-100">
        HN <span class="ml-1 opacity-70">{data?.stats.hn_stories || 0}</span>
      </button>
      <button data-source="producthunt" class="source-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-red-50 text-red-700 hover:bg-red-100">
        PH <span class="ml-1 opacity-70">{data?.stats.ph_products || 0}</span>
      </button>
    </div>

    <!-- Subreddit Tabs (shown when Reddit is selected) -->
    <div id="subreddit-tabs" class="hidden gap-2 mb-4 overflow-x-auto pb-2">
      <button data-subreddit="all" class="subreddit-tab active flex-shrink-0 px-3 py-1.5 rounded-full text-xs font-medium transition-all bg-orange-500 text-white">
        All Reddit
      </button>
      <button data-subreddit="SideProject" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        SideProject
      </button>
      <button data-subreddit="indiehackers" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        indiehackers
      </button>
      <button data-subreddit="Entrepreneur" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        Entrepreneur
      </button>
      <button data-subreddit="startups" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        startups
      </button>
      <button data-subreddit="resumes" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        resumes
      </button>
      <button data-subreddit="jobs" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        jobs
      </button>
      <button data-subreddit="careerguidance" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        careerguidance
      </button>
      <button data-subreddit="jobsearchhacks" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        jobsearchhacks
      </button>
    </div>

    <!-- Compact Filters -->
    <div id="filters-container" class="bg-white border border-cream-200 rounded-xl p-3 mb-6">
      <div class="flex flex-wrap items-center gap-3">
        <!-- Search -->
        <div class="flex-1 min-w-[200px]">
          <input
            type="text"
            id="search-input"
            placeholder="Search..."
            class="w-full px-3 py-1.5 text-sm border border-cream-200 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-accent/20 focus:border-accent"
          />
        </div>

        <!-- Quick filters -->
        <div class="flex items-center gap-2">
          <button id="filter-high-btn" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-amber-100 hover:text-amber-700 transition-all">
            â­ High
          </button>
          <button id="filter-saved-btn" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-rose-100 hover:text-rose-700 transition-all">
            â™¥ Saved <span id="saved-count" class="opacity-70">(0)</span>
          </button>
          <button id="filter-unread-btn" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-accent/10 hover:text-accent transition-all">
            â— Unread
          </button>
        </div>

        <!-- Hidden toggle -->
        <button id="filter-hidden-btn" class="hidden filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-400 hover:bg-ink-100 transition-all">
          Show Hidden <span id="hidden-count">(0)</span>
        </button>

        <!-- Count -->
        <div class="text-sm text-ink-500">
          <span id="visible-count">0</span> items
        </div>
      </div>
    </div>

    <!-- Hidden legacy elements for JS compatibility -->
    <select id="filter-source" class="hidden"><option value="all">All</option></select>
    <select id="filter-category" class="hidden"><option value="all">All</option></select>
    <input type="checkbox" id="filter-high" class="hidden" />
    <input type="checkbox" id="filter-saved" class="hidden" />
    <input type="checkbox" id="filter-show-hidden" class="hidden" />
    <span id="show-hidden-label" class="hidden"></span>

    <!-- Batch actions bar (hidden by default) -->
    <div id="batch-actions" class="hidden bg-accent/5 border border-accent/20 rounded-xl p-4 mb-6">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <input type="checkbox" id="select-all" class="w-4 h-4 rounded border-cream-300 text-accent focus:ring-accent/20" />
          <span class="text-sm text-ink-700"><span id="selected-count">0</span> selected</span>
        </div>
        <div class="flex items-center gap-2">
          <button
            id="batch-save"
            type="button"
            class="px-3 py-1.5 text-sm font-medium bg-rose-100 text-rose-700 rounded-lg hover:bg-rose-200 transition-colors flex items-center gap-1"
          >
            <span>â™¥</span> Save All
          </button>
          <button
            id="batch-hide"
            type="button"
            class="px-3 py-1.5 text-sm font-medium bg-ink-100 text-ink-600 rounded-lg hover:bg-ink-200 transition-colors flex items-center gap-1"
          >
            <span>âœ•</span> Hide All
          </button>
          <button
            id="batch-clear"
            type="button"
            class="px-3 py-1.5 text-sm font-medium text-ink-500 rounded-lg hover:bg-cream-100 transition-colors"
          >
            Clear
          </button>
        </div>
      </div>
    </div>

    <!-- X Content (hidden by default, shown when X tab is active) -->
    <!-- Content dynamically rendered via client-side fetch -->
    <div id="x-container" class="hidden">
      <div id="x-items-wrapper" class="space-y-6">
        <!-- X items rendered here by JavaScript -->
      </div>
      <div id="x-empty-state" class="hidden text-center py-12">
        <div class="text-4xl mb-4">ğ•</div>
        <h3 class="text-lg font-medium text-ink-700 mb-2">No X data available</h3>
        <p class="text-sm text-ink-500">X data will be loaded from API.</p>
      </div>
    </div>

    <!-- Items grid (Reddit/HN/PH) -->
    <!-- Content dynamically rendered via client-side fetch -->
    <div id="items-container" class="grid gap-4 md:grid-cols-2">
      <!-- Items rendered here by JavaScript -->
    </div>

    <!-- Empty state for saved -->
    <div id="empty-saved" class="hidden text-center py-12">
      <div class="text-4xl mb-4">â™¡</div>
      <h3 class="text-lg font-medium text-ink-700 mb-2">No saved items yet</h3>
      <p class="text-sm text-ink-500 mb-4">é»æ“Šæ¨™é¡ŒæŸ¥çœ‹åˆ†æï¼Œç„¶å¾ŒæŒ‰ â™¥ æ”¶è— ä»¥ä¿å­˜é …ç›®ã€‚</p>
      <button id="back-to-all" class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors">
        â† Back to All Items
      </button>
    </div>

    <!-- Empty state for no results -->
    <div id="empty-results" class="hidden text-center py-12">
      <div class="text-4xl mb-4">ğŸ”</div>
      <h3 class="text-lg font-medium text-ink-700 mb-2">No items found</h3>
      <p class="text-sm text-ink-500">Try adjusting your filters or search term.</p>
    </div>

    <!-- Loading state (always shown initially, hidden after data loads) -->
    <div id="loading-state" class="text-center py-12">
      <div class="flex items-center justify-center">
        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-accent"></div>
        <span class="ml-3 text-ink-500">Loading from API...</span>
      </div>
    </div>
  </div>

  <!-- Analysis Modal -->
  <div id="analysis-modal" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/50 backdrop-blur-sm" id="modal-backdrop"></div>
    <div class="absolute inset-4 md:inset-auto md:top-1/2 md:left-1/2 md:-translate-x-1/2 md:-translate-y-1/2 md:w-full md:max-w-2xl md:max-h-[80vh] bg-white rounded-xl shadow-2xl overflow-hidden flex flex-col">
      <!-- Modal header -->
      <div class="flex items-center justify-between p-4 border-b border-cream-200">
        <h2 class="text-lg font-semibold text-ink-900" id="modal-title">AI Analysis</h2>
        <button id="modal-close" class="p-2 hover:bg-cream-100 rounded-lg transition-colors">
          <svg class="w-5 h-5 text-ink-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      <!-- Modal content -->
      <div class="flex-1 overflow-y-auto p-4" id="modal-content">
        <div class="flex items-center justify-center py-8">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-accent"></div>
          <span class="ml-3 text-ink-500">Analyzing...</span>
        </div>
      </div>
      <!-- Modal footer -->
      <div class="p-4 border-t border-cream-200 flex items-center gap-2">
        <button id="modal-hide" class="px-3 py-2 text-sm font-medium text-red-600 hover:bg-red-50 rounded-lg transition-colors flex items-center gap-1">
          <span>ğŸ—‘ï¸</span> éš±è—
        </button>
        <button id="modal-save" class="px-3 py-2 text-sm font-medium text-rose-600 hover:bg-rose-50 rounded-lg transition-colors flex items-center gap-1">
          <span>â™¥</span> æ”¶è—
        </button>
        <div class="flex-1"></div>
        <button id="modal-copy" class="px-3 py-2 text-sm font-medium text-ink-600 hover:bg-cream-100 rounded-lg transition-colors">
          ğŸ“‹ Copy
        </button>
        <a id="modal-open" href="#" target="_blank" rel="noreferrer noopener" class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors">
          Open â†—
        </a>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
  // Panopticon - Data loaded from azure_container API
  // Reference: Cockpit/ideas/panopticon-db-architecture-plan.md (Phase 4)

  // API Configuration
  const API_BASE = 'https://airesumeadvisor-api-production.calmisland-ea7fe91e.japaneast.azurecontainerapps.io/api/v1/panopticon';

  // HTML escape function to prevent XSS
  function escapeHtml(str: string): string {
    if (!str) return '';
    const escapeMap: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return str.replace(/[&<>"']/g, c => escapeMap[c] || c);
  }

  // Store items data globally for pre-computed analysis lookup
  (window as any).__PANOPTICON_ITEMS__ = {};

  // Types
  interface AnalysisResult {
    summary_zh: string;
    why_popular: string;
    response_angles: string[];
    categories: string[];
    fb_score: number;
    blog_score: number;
  }

  interface ItemData {
    id: string;
    title: string;
    url: string;
    source: string;
    subreddit?: string;
    category?: string;
    selftext: string;
    score: number;
    comments: number;
    fbPotential: string;
    blogPotential: string;
  }

  interface PanopticonPrefs {
    saved: string[];
    hidden: string[];
    viewed: string[];
  }

  // localStorage keys
  const ANALYSIS_CACHE_KEY = 'panopticon-analysis-cache';
  const PREFS_KEY = 'panopticon-prefs';

  // Get/set preferences
  function getPrefs(): PanopticonPrefs {
    try {
      const stored = localStorage.getItem(PREFS_KEY);
      if (stored) {
        const prefs = JSON.parse(stored);
        // Ensure viewed array exists (backwards compatibility)
        if (!prefs.viewed) prefs.viewed = [];
        return prefs;
      }
    } catch {}
    return { saved: [], hidden: [], viewed: [] };
  }

  function setPrefs(prefs: PanopticonPrefs) {
    try {
      localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
    } catch (e) {
      console.error('Failed to save prefs:', e);
    }
  }

  function getCachedAnalysis(itemId: string): AnalysisResult | null {
    try {
      const cache = JSON.parse(localStorage.getItem(ANALYSIS_CACHE_KEY) || '{}');
      return cache[itemId] || null;
    } catch {
      return null;
    }
  }

  function setCachedAnalysis(itemId: string, analysis: AnalysisResult) {
    try {
      const cache = JSON.parse(localStorage.getItem(ANALYSIS_CACHE_KEY) || '{}');
      cache[itemId] = analysis;
      localStorage.setItem(ANALYSIS_CACHE_KEY, JSON.stringify(cache));
    } catch (e) {
      console.error('Failed to cache analysis:', e);
    }
  }

  // Current item being analyzed
  let currentItem: ItemData | null = null;
  let currentAnalysis: AnalysisResult | null = null;

  // Source display config
  const sourceConfig: Record<string, { label: string; color: string }> = {
    reddit: { label: 'Reddit', color: 'bg-orange-100 text-orange-700' },
    hackernews: { label: 'HN', color: 'bg-amber-100 text-amber-700' },
    producthunt: { label: 'PH', color: 'bg-red-100 text-red-700' },
  };

  // Potential badge colors
  const potentialColors: Record<string, string> = {
    High: 'bg-green-100 text-green-700',
    Medium: 'bg-yellow-100 text-yellow-700',
    Low: 'bg-gray-100 text-gray-500',
  };

  // X Category config
  const xCategoryConfig: Record<string, { label: string; color: string; bgColor: string }> = {
    ai_tech: { label: 'AI & Tech', color: 'text-purple-700', bgColor: 'bg-purple-50 border-purple-200' },
    indie_hacker: { label: 'Indie Hacker', color: 'text-green-700', bgColor: 'bg-green-50 border-green-200' },
    business: { label: 'Business & Politics', color: 'text-blue-700', bgColor: 'bg-blue-50 border-blue-200' },
    startup: { label: 'Startup & Investment', color: 'text-amber-700', bgColor: 'bg-amber-50 border-amber-200' },
    career: { label: 'Career', color: 'text-pink-700', bgColor: 'bg-pink-50 border-pink-200' },
    philosophy: { label: 'Philosophy & Mindset', color: 'text-indigo-700', bgColor: 'bg-indigo-50 border-indigo-200' },
    claude_code: { label: 'Claude Code', color: 'text-orange-700', bgColor: 'bg-orange-50 border-orange-200' },
  };

  // Render a single item card HTML
  function renderItemCard(item: any): string {
    const source = item.source || 'reddit';
    const sourceInfo = sourceConfig[source] || sourceConfig.reddit;
    const subreddit = item.subreddit || '';
    const sourceLabel = source === 'reddit' && subreddit ? `r/${escapeHtml(subreddit)}` : sourceInfo.label;
    const engagementScore = item.engagement_score || 1;
    const fbPotential = item.fb_potential || 'Low';
    const blogPotential = item.blog_potential || 'Low';
    const selftext = item.selftext || '';
    const truncatedText = selftext.length > 150 ? selftext.slice(0, 150) + '...' : selftext;

    return `
      <div
        class="item-card bg-white border border-cream-200 rounded-xl p-5 hover:shadow-md hover:border-accent/30 transition-all"
        data-source="${escapeHtml(source)}"
        data-category="${escapeHtml(item.category || '')}"
        data-score="${engagementScore}"
        data-id="${escapeHtml(item.id || item.item_id || '')}"
        data-title="${escapeHtml(item.title || '')}"
        data-url="${escapeHtml(item.url || '')}"
        data-selftext="${escapeHtml(selftext)}"
        data-subreddit="${escapeHtml(subreddit)}"
        data-points="${item.score || 0}"
        data-comments="${item.comments || 0}"
        data-fb-potential="${escapeHtml(fbPotential)}"
        data-blog-potential="${escapeHtml(blogPotential)}"
        style="border-left: 3px solid var(--color-accent, #d97706);"
      >
        <div class="flex items-start justify-between gap-3 mb-3">
          <div class="flex items-center gap-2 flex-wrap">
            <input type="checkbox" class="card-checkbox w-4 h-4 rounded border-cream-300 text-accent focus:ring-accent/20 cursor-pointer" title="Select for batch action" />
            ${engagementScore >= 4 ? '<span class="text-amber-500" title="High engagement">â­</span>' : ''}
            <span class="px-2 py-0.5 text-xs font-medium rounded-full ${sourceInfo.color}">${sourceLabel}</span>
            <span class="text-xs text-ink-400">${item.score || 0} pts Â· ${item.comments || 0} comments</span>
          </div>
          <span class="saved-indicator hidden text-rose-500 text-sm" title="Saved">â™¥</span>
        </div>
        <h3 class="card-title text-base font-bold text-ink-900 mb-2 line-clamp-2 cursor-pointer hover:text-accent transition-colors">
          ${escapeHtml(item.title || '')}
        </h3>
        ${truncatedText ? `<p class="text-sm text-ink-500 mb-3 line-clamp-3">${escapeHtml(truncatedText)}</p>` : ''}
        <div class="flex items-center gap-2 mb-4 text-xs">
          <span class="px-2 py-0.5 rounded-full ${potentialColors[fbPotential] || potentialColors.Low}">FB: ${escapeHtml(fbPotential)}</span>
          <span class="px-2 py-0.5 rounded-full ${potentialColors[blogPotential] || potentialColors.Low}">Blog: ${escapeHtml(blogPotential)}</span>
          <span class="text-ink-400">Score: ${engagementScore}/5</span>
        </div>
      </div>
    `;
  }

  // Render X item HTML
  // API returns: likes, retweets, replies, views directly (not nested in metrics)
  function renderXItem(item: any): string {
    const analysis = item.analysis || null;
    const engagementScore = item.engagement_score || 1;
    // API returns flat fields: likes, retweets, etc.
    const likes = item.likes || 0;
    const retweets = item.retweets || 0;

    return `
      <div class="x-item bg-white rounded-lg p-4 border border-gray-100" data-x-id="${escapeHtml(item.id || item.item_id || '')}">
        <div class="flex items-start justify-between mb-2">
          <div class="flex items-center gap-2">
            ${engagementScore >= 4 ? '<span class="text-amber-500">â­</span>' : ''}
            <span class="text-xs text-gray-500">${likes} â¤ï¸ Â· ${retweets} ğŸ”</span>
          </div>
          <a href="${escapeHtml(item.url || '#')}" target="_blank" rel="noopener noreferrer" class="text-sky-500 hover:text-sky-600 text-sm">â†—</a>
        </div>
        <p class="text-sm text-gray-700 mb-2 whitespace-pre-wrap">${escapeHtml(item.original_text || '')}</p>
        ${analysis?.translation ? `<p class="text-sm text-gray-600 bg-gray-50 p-2 rounded mt-2"><strong>ç¿»è­¯:</strong> ${escapeHtml(analysis.translation)}</p>` : ''}
        ${analysis?.summary ? `<p class="text-xs text-gray-500 mt-1">${escapeHtml(analysis.summary)}</p>` : ''}
      </div>
    `;
  }

  // Render X category section
  // API returns: author_handle, author_name, author_category (not author, category)
  function renderXCategory(category: string, items: any[]): string {
    const config = xCategoryConfig[category] || { label: category, color: 'text-gray-700', bgColor: 'bg-gray-50 border-gray-200' };

    // Group by author - API uses author_handle field
    const byAuthor: Record<string, { authorName: string; items: any[] }> = {};
    items.forEach(item => {
      const author = item.author_handle || item.author || 'unknown';
      if (!byAuthor[author]) {
        byAuthor[author] = { authorName: item.author_name || author, items: [] };
      }
      byAuthor[author].items.push(item);
    });

    const authorSections = Object.entries(byAuthor).map(([author, data]) => `
      <div class="mb-4">
        <h3 class="text-sm font-semibold mb-2 flex items-center gap-2">
          <span class="text-gray-700">@${author}</span>
          <span class="text-xs text-gray-500 font-normal">${data.authorName}</span>
        </h3>
        <div class="space-y-3 pl-4 border-l-2 border-gray-200">
          ${data.items.map(item => renderXItem(item)).join('')}
        </div>
      </div>
    `).join('');

    return `
      <section class="x-category-section mb-8 rounded-xl border p-4 ${config.bgColor}" data-x-category="${category}">
        <h2 class="text-lg font-bold mb-4 flex items-center gap-2 ${config.color}">
          <span>${config.label}</span>
          <span class="text-sm font-normal opacity-70">(${items.length} tweets from ${Object.keys(byAuthor).length} KOLs)</span>
        </h2>
        <div class="space-y-6">${authorSections}</div>
      </section>
    `;
  }

  // Fetch and render data from API
  async function loadDataFromAPI() {
    const loadingEl = document.getElementById('loading-state');
    const container = document.getElementById('items-container');
    const xContainer = document.getElementById('x-container');
    const xWrapper = document.getElementById('x-items-wrapper');
    const xEmptyState = document.getElementById('x-empty-state');
    const dateDisplay = document.getElementById('date-display');

    try {
      // Fetch both content and X data in parallel (GET endpoints, no API key needed)
      const [contentRes, xRes] = await Promise.all([
        fetch(`${API_BASE}/latest?source=content`),
        fetch(`${API_BASE}/latest?source=x`)
      ]);

      const contentData = await contentRes.json();
      const xData = await xRes.json();

      // Update date display
      if (dateDisplay && contentData.success) {
        const batch = contentData.data?.batch;
        dateDisplay.textContent = batch?.date || 'Today';
      }

      // Render content items
      if (contentData.success && contentData.data?.items?.length > 0) {
        const items = contentData.data.items;

        // Store items for analysis lookup
        (window as any).__PANOPTICON_ITEMS__ = items.reduce((acc: any, item: any) => {
          acc[item.item_id || item.id] = item;
          return acc;
        }, {});

        // Render HTML
        if (container) {
          container.innerHTML = items.map((item: any) => renderItemCard(item)).join('');
        }

        // Update stats - API returns stats directly under data, not data.batch.stats
        const stats = contentData.data.stats || {};
        updateStatsCounts(stats, items.length);
      }

      // Render X items
      if (xData.success && xData.data?.items?.length > 0) {
        const items = xData.data.items;
        const categoryOrder = ['ai_tech', 'indie_hacker', 'business', 'startup', 'career', 'philosophy', 'claude_code'];

        // Group by category - API uses author_category field (not category)
        const byCategory: Record<string, any[]> = {};
        items.forEach((item: any) => {
          const cat = item.author_category || item.category || 'other';
          if (!byCategory[cat]) byCategory[cat] = [];
          byCategory[cat].push(item);
        });

        // Render in order
        const xHtml = categoryOrder
          .filter(cat => byCategory[cat]?.length > 0)
          .map(cat => renderXCategory(cat, byCategory[cat]))
          .join('');

        if (xWrapper) {
          xWrapper.innerHTML = xHtml;
        }
        if (xEmptyState) {
          xEmptyState.classList.add('hidden');
        }

        // Update X stats
        updateXStatsCounts(items.length);
      } else {
        if (xEmptyState) {
          xEmptyState.classList.remove('hidden');
        }
      }

      // Hide loading, show content
      if (loadingEl) loadingEl.style.display = 'none';

    } catch (error) {
      console.error('Failed to load Panopticon data:', error);
      if (loadingEl) {
        loadingEl.innerHTML = `
          <div class="text-center py-12">
            <p class="text-red-500 mb-2">Failed to load data from API</p>
            <p class="text-sm text-ink-500 mb-4">${error}</p>
            <button onclick="loadDataFromAPI()" class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors">
              Retry
            </button>
          </div>
        `;
      }
    }
  }

  // Store counts for computing total
  let contentItemsCount = 0;
  let xItemsCount = 0;

  // Update stats counts in the source tabs
  function updateStatsCounts(stats: any, totalItems: number) {
    contentItemsCount = totalItems;
    const tabs = document.querySelectorAll('.source-tab');
    tabs.forEach(tab => {
      const source = (tab as HTMLElement).dataset.source;
      const countSpan = tab.querySelector('span');
      if (countSpan) {
        // All tab should show content + X items
        if (source === 'all') countSpan.textContent = String(contentItemsCount + xItemsCount);
        else if (source === 'reddit') countSpan.textContent = String(stats.reddit_posts || 0);
        else if (source === 'hackernews') countSpan.textContent = String(stats.hn_stories || 0);
        else if (source === 'producthunt') countSpan.textContent = String(stats.ph_products || 0);
      }
    });
  }

  function updateXStatsCounts(count: number) {
    xItemsCount = count;
    const xTab = document.querySelector('.source-tab[data-source="x"]');
    if (xTab) {
      const countSpan = xTab.querySelector('span');
      if (countSpan) countSpan.textContent = String(count);
    }
    // Also update All tab to include X count
    const allTab = document.querySelector('.source-tab[data-source="all"]');
    if (allTab) {
      const countSpan = allTab.querySelector('span');
      if (countSpan) countSpan.textContent = String(contentItemsCount + xItemsCount);
    }
  }

  function initPanopticon() {
    const container = document.getElementById('items-container');
    const sourceFilter = document.getElementById('filter-source') as HTMLSelectElement;
    const categoryFilter = document.getElementById('filter-category') as HTMLSelectElement;
    const highOnlyFilter = document.getElementById('filter-high') as HTMLInputElement;
    const savedFilter = document.getElementById('filter-saved') as HTMLInputElement;
    const showHiddenFilter = document.getElementById('filter-show-hidden') as HTMLInputElement;
    const showHiddenLabel = document.getElementById('show-hidden-label');
    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const visibleCount = document.getElementById('visible-count');
    const savedCountEl = document.getElementById('saved-count');
    const hiddenCountEl = document.getElementById('hidden-count');
    const refreshBtn = document.getElementById('refresh-btn');
    const modal = document.getElementById('analysis-modal');
    const modalBackdrop = document.getElementById('modal-backdrop');
    const modalClose = document.getElementById('modal-close');
    const modalContent = document.getElementById('modal-content');
    const modalTitle = document.getElementById('modal-title');
    const modalCopy = document.getElementById('modal-copy');
    const modalHide = document.getElementById('modal-hide');
    const modalSave = document.getElementById('modal-save');
    const modalOpen = document.getElementById('modal-open') as HTMLAnchorElement;
    const batchActions = document.getElementById('batch-actions');
    const selectAll = document.getElementById('select-all') as HTMLInputElement;
    const selectedCountEl = document.getElementById('selected-count');
    const batchSave = document.getElementById('batch-save');
    const batchHide = document.getElementById('batch-hide');
    const batchClear = document.getElementById('batch-clear');
    const emptySaved = document.getElementById('empty-saved');
    const emptyResults = document.getElementById('empty-results');
    const backToAll = document.getElementById('back-to-all');

    // New UI elements
    const sourceTabs = document.getElementById('source-tabs');
    const subredditTabs = document.getElementById('subreddit-tabs');
    const filterHighBtn = document.getElementById('filter-high-btn');
    const filterSavedBtn = document.getElementById('filter-saved-btn');
    const filterUnreadBtn = document.getElementById('filter-unread-btn');
    const filterHiddenBtn = document.getElementById('filter-hidden-btn');

    if (!container) return;

    let prefs = getPrefs();

    // Current filter state
    let currentSource = 'all';
    let currentSubreddit = 'all';
    let filterHigh = false;
    let filterSaved = false;
    let filterUnread = false;
    let filterShowHidden = false;

    // Update counts
    function updateCounts() {
      if (savedCountEl) savedCountEl.textContent = `(${prefs.saved.length})`;
      if (hiddenCountEl) hiddenCountEl.textContent = `(${prefs.hidden.length})`;
      // Show hidden button if there are hidden items
      if (filterHiddenBtn) {
        filterHiddenBtn.classList.toggle('hidden', prefs.hidden.length === 0);
      }
    }

    // Apply saved/hidden/viewed states to cards
    function applyStates() {
      const cards = container!.querySelectorAll('.item-card');
      cards.forEach((card) => {
        const el = card as HTMLElement;
        const id = el.dataset.id || '';
        el.classList.toggle('is-saved', prefs.saved.includes(id));
        el.classList.toggle('is-hidden', prefs.hidden.includes(id));
        el.classList.toggle('is-viewed', prefs.viewed.includes(id));
      });
    }

    // Filter function
    function applyFilters() {
      const searchTerm = searchInput?.value.toLowerCase() || '';

      const cards = container!.querySelectorAll('.item-card');
      let count = 0;

      cards.forEach((card) => {
        const el = card as HTMLElement;
        const cardId = el.dataset.id || '';
        const cardSource = el.dataset.source;
        const cardSubreddit = el.dataset.subreddit || '';
        const cardScore = parseInt(el.dataset.score || '0', 10);
        const cardTitle = (el.dataset.title || '').toLowerCase();
        const cardSelftext = (el.dataset.selftext || '').toLowerCase();

        const isSaved = prefs.saved.includes(cardId);
        const isHidden = prefs.hidden.includes(cardId);
        const isViewed = prefs.viewed.includes(cardId);

        const sourceMatch = currentSource === 'all' || cardSource === currentSource;
        const subredditMatch = currentSubreddit === 'all' || cardSubreddit === currentSubreddit;
        const scoreMatch = !filterHigh || cardScore >= 4;
        const searchMatch = !searchTerm || cardTitle.includes(searchTerm) || cardSelftext.includes(searchTerm);
        const savedMatch = !filterSaved || isSaved;
        const unreadMatch = !filterUnread || !isViewed;
        const hiddenMatch = filterShowHidden || !isHidden;

        if (sourceMatch && subredditMatch && scoreMatch && searchMatch && savedMatch && unreadMatch && hiddenMatch) {
          el.style.display = '';
          count++;
        } else {
          el.style.display = 'none';
        }
      });

      if (visibleCount) {
        visibleCount.textContent = count.toString();
      }

      // Show empty states
      const showSavedEmpty = filterSaved && prefs.saved.length === 0;
      const showNoResults = !showSavedEmpty && count === 0;

      emptySaved?.classList.toggle('hidden', !showSavedEmpty);
      emptyResults?.classList.toggle('hidden', !showNoResults);
      container!.classList.toggle('hidden', showSavedEmpty || showNoResults);

      updateSelectedCount();
    }

    // Update selected count
    function updateSelectedCount() {
      const checkboxes = container!.querySelectorAll('.card-checkbox:checked');
      const visibleChecked = Array.from(checkboxes).filter((cb) => {
        const card = (cb as HTMLElement).closest('.item-card') as HTMLElement;
        return card && card.style.display !== 'none';
      });
      const count = visibleChecked.length;

      if (selectedCountEl) selectedCountEl.textContent = count.toString();
      batchActions?.classList.toggle('hidden', count === 0);
    }

    // Helper: Update tab styles
    function updateSourceTabStyles() {
      sourceTabs?.querySelectorAll('.source-tab').forEach((tab) => {
        const t = tab as HTMLElement;
        const isActive = t.dataset.source === currentSource;
        t.classList.toggle('active', isActive);

        // Reset all to default styles first
        t.classList.remove('bg-accent', 'text-white', 'bg-sky-500', 'bg-orange-500', 'bg-amber-500', 'bg-red-500');

        if (isActive) {
          if (currentSource === 'all') {
            t.classList.add('bg-accent', 'text-white');
          } else if (currentSource === 'x') {
            t.classList.add('bg-sky-500', 'text-white');
            t.classList.remove('bg-sky-50', 'text-sky-700');
          } else if (currentSource === 'reddit') {
            t.classList.add('bg-orange-500', 'text-white');
            t.classList.remove('bg-orange-50', 'text-orange-700');
          } else if (currentSource === 'hackernews') {
            t.classList.add('bg-amber-500', 'text-white');
            t.classList.remove('bg-amber-50', 'text-amber-700');
          } else if (currentSource === 'producthunt') {
            t.classList.add('bg-red-500', 'text-white');
            t.classList.remove('bg-red-50', 'text-red-700');
          }
        } else {
          // Restore default colors
          if (t.dataset.source === 'x') {
            t.classList.add('bg-sky-50', 'text-sky-700');
          } else if (t.dataset.source === 'reddit') {
            t.classList.add('bg-orange-50', 'text-orange-700');
          } else if (t.dataset.source === 'hackernews') {
            t.classList.add('bg-amber-50', 'text-amber-700');
          } else if (t.dataset.source === 'producthunt') {
            t.classList.add('bg-red-50', 'text-red-700');
          }
        }
      });
    }

    function updateSubredditTabStyles() {
      subredditTabs?.querySelectorAll('.subreddit-tab').forEach((tab) => {
        const t = tab as HTMLElement;
        const isActive = t.dataset.subreddit === currentSubreddit;
        t.classList.toggle('active', isActive);

        if (isActive) {
          t.classList.add('bg-orange-500', 'text-white');
          t.classList.remove('bg-cream-100', 'text-ink-600');
        } else {
          t.classList.remove('bg-orange-500', 'text-white');
          t.classList.add('bg-cream-100', 'text-ink-600');
        }
      });
    }

    function updateFilterBtnStyles() {
      filterHighBtn?.classList.toggle('bg-amber-200', filterHigh);
      filterHighBtn?.classList.toggle('text-amber-800', filterHigh);
      filterSavedBtn?.classList.toggle('bg-rose-200', filterSaved);
      filterSavedBtn?.classList.toggle('text-rose-800', filterSaved);
      filterUnreadBtn?.classList.toggle('bg-accent/20', filterUnread);
      filterUnreadBtn?.classList.toggle('text-accent', filterUnread);
      filterHiddenBtn?.classList.toggle('bg-ink-200', filterShowHidden);
    }

    // X container reference
    const xContainer = document.getElementById('x-container');

    // Source tab click handlers
    sourceTabs?.querySelectorAll('.source-tab').forEach((tab) => {
      tab.addEventListener('click', () => {
        currentSource = (tab as HTMLElement).dataset.source || 'all';
        currentSubreddit = 'all'; // Reset subreddit when changing source

        // Show/hide X container vs items container
        if (currentSource === 'x') {
          xContainer?.classList.remove('hidden');
          container?.classList.add('hidden');
          subredditTabs?.classList.add('hidden');
          subredditTabs?.classList.remove('flex');
          // Hide filters for X view
          document.getElementById('filters-container')?.classList.add('hidden');
        } else {
          xContainer?.classList.add('hidden');
          container?.classList.remove('hidden');
          // Show filters for non-X view
          document.getElementById('filters-container')?.classList.remove('hidden');
          // Show/hide subreddit tabs
          if (currentSource === 'reddit') {
            subredditTabs?.classList.remove('hidden');
            subredditTabs?.classList.add('flex');
          } else {
            subredditTabs?.classList.add('hidden');
            subredditTabs?.classList.remove('flex');
          }
        }

        updateSourceTabStyles();
        updateSubredditTabStyles();
        if (currentSource !== 'x') {
          applyFilters();
        }
      });
    });

    // Subreddit tab click handlers
    subredditTabs?.querySelectorAll('.subreddit-tab').forEach((tab) => {
      tab.addEventListener('click', () => {
        currentSubreddit = (tab as HTMLElement).dataset.subreddit || 'all';
        updateSubredditTabStyles();
        applyFilters();
      });
    });

    // Filter button handlers
    filterHighBtn?.addEventListener('click', () => {
      filterHigh = !filterHigh;
      updateFilterBtnStyles();
      applyFilters();
    });

    filterSavedBtn?.addEventListener('click', () => {
      filterSaved = !filterSaved;
      updateFilterBtnStyles();
      applyFilters();
    });

    filterUnreadBtn?.addEventListener('click', () => {
      filterUnread = !filterUnread;
      updateFilterBtnStyles();
      applyFilters();
    });

    filterHiddenBtn?.addEventListener('click', () => {
      filterShowHidden = !filterShowHidden;
      updateFilterBtnStyles();
      applyFilters();
    });

    // Debounced search
    let searchTimeout: ReturnType<typeof setTimeout>;
    searchInput?.addEventListener('input', () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(applyFilters, 300);
    });

    // Back to all button
    backToAll?.addEventListener('click', () => {
      filterSaved = false;
      updateFilterBtnStyles();
      applyFilters();
    });

    // Checkbox handlers
    container.querySelectorAll('.card-checkbox').forEach((cb) => {
      cb.addEventListener('change', updateSelectedCount);
      cb.addEventListener('click', (e) => e.stopPropagation());
    });

    // Select all
    selectAll?.addEventListener('change', () => {
      const visibleCards = Array.from(container!.querySelectorAll('.item-card')).filter(
        (card) => (card as HTMLElement).style.display !== 'none'
      );
      visibleCards.forEach((card) => {
        const cb = card.querySelector('.card-checkbox') as HTMLInputElement;
        if (cb) cb.checked = selectAll.checked;
      });
      updateSelectedCount();
    });

    // Batch save
    batchSave?.addEventListener('click', () => {
      const checkedCards = container!.querySelectorAll('.item-card:has(.card-checkbox:checked)');
      checkedCards.forEach((card) => {
        const id = (card as HTMLElement).dataset.id || '';
        if (!prefs.saved.includes(id)) {
          prefs.saved.push(id);
        }
        // Uncheck
        const cb = card.querySelector('.card-checkbox') as HTMLInputElement;
        if (cb) cb.checked = false;
      });
      setPrefs(prefs);
      applyStates();
      updateCounts();
      updateSelectedCount();
    });

    // Batch hide
    batchHide?.addEventListener('click', () => {
      const checkedCards = container!.querySelectorAll('.item-card:has(.card-checkbox:checked)');
      checkedCards.forEach((card) => {
        const id = (card as HTMLElement).dataset.id || '';
        if (!prefs.hidden.includes(id)) {
          prefs.hidden.push(id);
        }
        // Uncheck
        const cb = card.querySelector('.card-checkbox') as HTMLInputElement;
        if (cb) cb.checked = false;
      });
      setPrefs(prefs);
      applyStates();
      updateCounts();
      applyFilters();
    });

    // Batch clear selection
    batchClear?.addEventListener('click', () => {
      container!.querySelectorAll('.card-checkbox').forEach((cb) => {
        (cb as HTMLInputElement).checked = false;
      });
      if (selectAll) selectAll.checked = false;
      updateSelectedCount();
    });

    // Initialize states
    applyStates();
    updateCounts();
    applyFilters();

    // Refresh button - reload data from API
    refreshBtn?.addEventListener('click', async () => {
      const btn = refreshBtn as HTMLButtonElement;
      btn.disabled = true;
      btn.innerHTML = `
        <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
        Loading...
      `;

      try {
        await loadDataFromAPI();
        // Re-initialize UI after data reload
        prefs = getPrefs();
        applyStates();
        updateCounts();
        applyFilters();

        // Rebind title click handlers for new cards
        container?.querySelectorAll('.card-title').forEach((title) => {
          title.addEventListener('click', (e) => {
            e.stopPropagation();
            const card = (title as HTMLElement).closest('.item-card') as HTMLElement;
            if (card) handleAnalyze(card);
          });
        });

        btn.innerHTML = `
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
          </svg>
          Done!
        `;
      } catch (e) {
        console.error('Refresh failed:', e);
        btn.innerHTML = `
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
          Failed
        `;
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.innerHTML = `
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            Refresh
          `;
        }, 2000);
      }
    });

    // Modal functions
    function openModal() {
      modal?.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
    }

    function closeModal() {
      modal?.classList.add('hidden');
      document.body.style.overflow = '';
      currentItem = null;
      currentAnalysis = null;
    }

    function renderAnalysis(analysis: AnalysisResult) {
      if (!modalContent) return;

      const categoryLabels: Record<string, string> = {
        industry_thoughts: 'è¡Œæ¥­æ€è€ƒ',
        values: 'äººç”Ÿåƒ¹å€¼è§€',
        personal_growth: 'å€‹äººæˆé•·',
        achievements: 'äººç”Ÿæˆå°±',
        testimonials: 'å®¢æˆ¶è­‰è¨€',
      };

      // Get original English content from currentItem
      const originalTitle = currentItem?.title || '';
      const originalSelftext = currentItem?.selftext || '';

      modalContent.innerHTML = `
        <div class="space-y-4">
          <!-- English Original -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">ğŸ“„ è‹±æ–‡åŸæ–‡</h3>
            <div class="bg-cream-50 rounded-lg p-3 text-ink-800">
              <p class="font-medium mb-2">${originalTitle}</p>
              ${originalSelftext ? `<p class="text-sm text-ink-600 whitespace-pre-wrap">${originalSelftext}</p>` : '<p class="text-sm text-ink-400 italic">(ç„¡å…§å®¹)</p>'}
            </div>
          </div>

          <!-- Chinese Summary -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">ğŸ“ ä¸­æ–‡æ‘˜è¦</h3>
            <p class="text-ink-900">${analysis.summary_zh}</p>
          </div>

          <!-- Why Popular -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">ğŸ”¥ ç‚ºä»€éº¼å—æ­¡è¿</h3>
            <p class="text-ink-900">${analysis.why_popular}</p>
          </div>

          <!-- Response Angles (Collapsible) -->
          <div>
            <button id="toggle-angles" class="flex items-center gap-2 text-sm font-medium text-ink-500 hover:text-ink-700 transition-colors">
              <span>ğŸ’¡ å›æ‡‰è§’åº¦å»ºè­°</span>
              <svg class="w-4 h-4 transform transition-transform" id="angles-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </button>
            <div id="angles-content" class="hidden mt-2">
              <ul class="list-disc list-inside text-ink-900 space-y-1 pl-2">
                ${analysis.response_angles.map(a => `<li>${a}</li>`).join('')}
              </ul>
            </div>
          </div>

          <!-- Categories -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">ğŸ·ï¸ å…§å®¹åˆ†é¡</h3>
            <div class="flex flex-wrap gap-2">
              ${analysis.categories.map(c => `<span class="px-2 py-1 text-xs bg-cream-100 text-ink-700 rounded-full">${categoryLabels[c] || c}</span>`).join('')}
            </div>
          </div>

          <!-- Scores -->
          <div class="flex gap-6 pt-2">
            <div>
              <h3 class="text-sm font-medium text-ink-500 mb-1">FB é©åˆåº¦</h3>
              <div class="text-2xl font-bold text-accent">${analysis.fb_score}/5</div>
            </div>
            <div>
              <h3 class="text-sm font-medium text-ink-500 mb-1">Blog é©åˆåº¦</h3>
              <div class="text-2xl font-bold text-accent">${analysis.blog_score}/5</div>
            </div>
          </div>
        </div>
      `;

      // Add toggle handler for response angles
      const toggleBtn = document.getElementById('toggle-angles');
      const anglesContent = document.getElementById('angles-content');
      const anglesArrow = document.getElementById('angles-arrow');

      toggleBtn?.addEventListener('click', () => {
        anglesContent?.classList.toggle('hidden');
        anglesArrow?.classList.toggle('rotate-180');
      });
    }

    // Analyze button handlers (and title click)
    function handleAnalyze(card: HTMLElement) {
      const itemId = card.dataset.id || '';

      currentItem = {
        id: itemId,
        title: card.dataset.title || '',
        url: card.dataset.url || '',
        source: card.dataset.source || '',
        subreddit: card.dataset.subreddit,
        category: card.dataset.category,
        selftext: card.dataset.selftext || '',
        score: parseInt(card.dataset.points || '0', 10),
        comments: parseInt(card.dataset.comments || '0', 10),
        fbPotential: card.dataset.fbPotential || '',
        blogPotential: card.dataset.blogPotential || '',
      };

      // Mark as viewed
      if (!prefs.viewed.includes(itemId)) {
        prefs.viewed.push(itemId);
        setPrefs(prefs);
        card.classList.add('is-viewed');
      }

      // Set modal Open link
      if (modalOpen) {
        modalOpen.href = currentItem.url;
      }

      if (modalTitle) {
        modalTitle.textContent = currentItem.title.slice(0, 50) + (currentItem.title.length > 50 ? '...' : '');
      }

      // Check for pre-computed analysis from batch processing
      const itemsStore = (window as any).__PANOPTICON_ITEMS__ || {};
      const storedItem = itemsStore[itemId];
      if (storedItem?.ai_analysis) {
        currentAnalysis = storedItem.ai_analysis;
        renderAnalysis(storedItem.ai_analysis);
        openModal();
        return;
      }

      // Check localStorage cache (for previously viewed analysis)
      const cached = getCachedAnalysis(itemId);
      if (cached) {
        currentAnalysis = cached;
        renderAnalysis(cached);
        openModal();
        return;
      }

      // No pre-computed analysis available - show message with original content
      if (modalContent) {
        const originalTitle = currentItem?.title || '';
        const originalSelftext = currentItem?.selftext || '';

        modalContent.innerHTML = `
          <div class="space-y-4">
            <div class="bg-amber-50 border border-amber-200 rounded-lg p-4">
              <p class="text-amber-800 text-sm">
                <strong>AI åˆ†æå°šæœªæº–å‚™å¥½</strong><br>
                æ­¤é …ç›®çš„ AI åˆ†æå°‡åœ¨ä¸‹æ¬¡ batch è™•ç†æ™‚ç”Ÿæˆã€‚
              </p>
            </div>

            <div>
              <h3 class="text-sm font-medium text-ink-500 mb-1">ğŸ“„ åŸæ–‡å…§å®¹</h3>
              <div class="bg-cream-50 rounded-lg p-3 text-ink-800">
                <p class="font-medium mb-2">${escapeHtml(originalTitle)}</p>
                ${originalSelftext ? `<p class="text-sm text-ink-600 whitespace-pre-wrap">${escapeHtml(originalSelftext)}</p>` : '<p class="text-sm text-ink-400 italic">(ç„¡å…§å®¹)</p>'}
              </div>
            </div>
          </div>
        `;
      }
      openModal();
    }

    // Title click for analysis
    container.querySelectorAll('.card-title').forEach((title) => {
      title.addEventListener('click', (e) => {
        e.stopPropagation();
        const card = (title as HTMLElement).closest('.item-card') as HTMLElement;
        if (card) handleAnalyze(card);
      });
    });

    // Modal close handlers
    modalBackdrop?.addEventListener('click', closeModal);
    modalClose?.addEventListener('click', closeModal);

    // Copy with analysis
    modalCopy?.addEventListener('click', async () => {
      if (!currentItem || !currentAnalysis) return;

      const text = `## æ–‡ç« è³‡è¨Š
æ¨™é¡Œ: ${currentItem.title}
ä¾†æº: ${currentItem.source}${currentItem.subreddit ? ` (r/${currentItem.subreddit})` : currentItem.category ? ` (${currentItem.category})` : ''}
åˆ†æ•¸: ${currentItem.score} | è©•è«–: ${currentItem.comments}
é€£çµ: ${currentItem.url}

## åŸæ–‡æ‘˜è¦
${currentItem.selftext || '(ç„¡å…§å®¹)'}

## AI åˆ†æ
${currentAnalysis.summary_zh}

ç‚ºä»€éº¼å—æ­¡è¿: ${currentAnalysis.why_popular}

å›æ‡‰è§’åº¦:
${currentAnalysis.response_angles.map(a => `- ${a}`).join('\n')}

---
è«‹å¹«æˆ‘é‡å°é€™ç¯‡æ–‡ç« æ’°å¯«å›æ‡‰/FB è²¼æ–‡/Blog æ–‡ç« ã€‚`;

      try {
        await navigator.clipboard.writeText(text);
        const btn = modalCopy as HTMLButtonElement;
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => {
          btn.textContent = originalText;
        }, 1500);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });

    // Modal Hide button
    modalHide?.addEventListener('click', () => {
      if (!currentItem) return;
      const id = currentItem.id;
      if (!prefs.hidden.includes(id)) {
        prefs.hidden.push(id);
        setPrefs(prefs);
        updateCounts();
        applyFilters();
      }
      closeModal();
    });

    // Modal Save button
    modalSave?.addEventListener('click', () => {
      if (!currentItem) return;
      const id = currentItem.id;
      if (!prefs.saved.includes(id)) {
        prefs.saved.push(id);
        setPrefs(prefs);
        // Update card visual state
        const card = container?.querySelector(`[data-id="${id}"]`);
        card?.classList.add('is-saved');
        updateCounts();
      }
      closeModal();
    });

    // ESC to close modal
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !modal?.classList.contains('hidden')) {
        closeModal();
      }
    });
  }

  // Initialize - first load data from API, then setup UI handlers
  async function init() {
    await loadDataFromAPI();
    initPanopticon();
  }

  init();
  document.addEventListener('astro:after-swap', init);
</script>

<style>
  .item-card.is-hidden {
    opacity: 0.5;
  }
</style>
