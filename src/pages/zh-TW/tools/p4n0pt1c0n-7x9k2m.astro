---
import BaseLayout from '../../../layouts/BaseLayout.astro';

// Type definitions (kept for reference, data loaded client-side now)
// Data is now fetched from azure_container API at runtime
// See: Cockpit/ideas/panopticon-db-architecture-plan.md (Phase 4)

// Empty initial state - data loaded via client-side fetch
// Using 'as any' to allow template access before client-side hydration
const data = null as any;
const xData = null as any;
---

<BaseLayout
  title="Content Discovery"
  description="Personal content discovery tool"
  noindex={true}
  hideLanguageSwitcher={true}
>
  <div class="max-w-5xl mx-auto px-4 py-8">
    <!-- Header -->
    <div class="flex items-center justify-between mb-6">
      <div>
        <h1 class="text-2xl font-bold text-ink-900 mb-1">Content Discovery</h1>
        <p class="text-ink-500" id="date-display">
          {data ? data.date : 'Loading...'}
        </p>
      </div>
      <button
        id="refresh-btn"
        type="button"
        class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors flex items-center gap-2"
      >
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
        Refresh
      </button>
    </div>

    <!-- Primary Tabs (X vs Community) -->
    <div id="primary-tabs" class="flex gap-3 mb-4">
      <button data-primary="x" class="primary-tab flex-shrink-0 px-5 py-2.5 rounded-xl text-sm font-semibold transition-all bg-sky-500 text-white shadow-sm">
        ùïè Twitter <span class="ml-1.5 opacity-80" id="x-count-primary">0</span>
      </button>
      <button data-primary="community" class="primary-tab flex-shrink-0 px-5 py-2.5 rounded-xl text-sm font-semibold transition-all bg-cream-100 text-ink-600 hover:bg-cream-200">
        Community <span class="ml-1.5 opacity-70" id="community-count-primary">0</span>
      </button>
    </div>

    <!-- X Category Tabs (shown when X is selected) -->
    <div id="x-category-tabs" class="flex gap-2 mb-4 overflow-x-auto pb-2">
      <button data-x-cat="all" class="x-cat-tab active flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-sky-500 text-white">
        All <span class="ml-1 opacity-80" id="x-cat-all-count">0</span>
      </button>
      <button data-x-cat="ai_tech" class="x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-purple-50 text-purple-700 hover:bg-purple-100">
        AI & Tech <span class="ml-1 opacity-70">0</span>
      </button>
      <button data-x-cat="indie_hacker" class="x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-green-50 text-green-700 hover:bg-green-100">
        Indie Hacker <span class="ml-1 opacity-70">0</span>
      </button>
      <button data-x-cat="business" class="x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-blue-50 text-blue-700 hover:bg-blue-100">
        Business <span class="ml-1 opacity-70">0</span>
      </button>
      <button data-x-cat="startup" class="x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-amber-50 text-amber-700 hover:bg-amber-100">
        Startup <span class="ml-1 opacity-70">0</span>
      </button>
      <button data-x-cat="career" class="x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-pink-50 text-pink-700 hover:bg-pink-100">
        Career <span class="ml-1 opacity-70">0</span>
      </button>
      <button data-x-cat="philosophy" class="x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-indigo-50 text-indigo-700 hover:bg-indigo-100">
        Philosophy <span class="ml-1 opacity-70">0</span>
      </button>
      <button data-x-cat="claude_code" class="x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-orange-50 text-orange-700 hover:bg-orange-100">
        Claude Code <span class="ml-1 opacity-70">0</span>
      </button>
    </div>

    <!-- Secondary Source Tabs (shown when Community is selected) -->
    <div id="source-tabs" class="hidden gap-2 mb-4 overflow-x-auto pb-2">
      <button data-source="all" class="source-tab active flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-accent text-white">
        All <span class="ml-1 opacity-80">{data?.stats.total_items || 0}</span>
      </button>
      <button data-source="reddit" class="source-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-orange-50 text-orange-700 hover:bg-orange-100">
        Reddit <span class="ml-1 opacity-70">{data?.stats.reddit_posts || 0}</span>
      </button>
      <button data-source="hackernews" class="source-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-amber-50 text-amber-700 hover:bg-amber-100">
        HN <span class="ml-1 opacity-70">{data?.stats.hn_stories || 0}</span>
      </button>
      <button data-source="producthunt" class="source-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all bg-red-50 text-red-700 hover:bg-red-100">
        PH <span class="ml-1 opacity-70">{data?.stats.ph_products || 0}</span>
      </button>
    </div>

    <!-- Subreddit Tabs (shown when Reddit is selected) -->
    <div id="subreddit-tabs" class="hidden gap-2 mb-4 overflow-x-auto pb-2">
      <button data-subreddit="all" class="subreddit-tab active flex-shrink-0 px-3 py-1.5 rounded-full text-xs font-medium transition-all bg-orange-500 text-white">
        All Reddit
      </button>
      <button data-subreddit="SideProject" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        SideProject
      </button>
      <button data-subreddit="indiehackers" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        indiehackers
      </button>
      <button data-subreddit="Entrepreneur" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        Entrepreneur
      </button>
      <button data-subreddit="startups" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        startups
      </button>
      <button data-subreddit="resumes" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        resumes
      </button>
      <button data-subreddit="jobs" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        jobs
      </button>
      <button data-subreddit="careerguidance" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        careerguidance
      </button>
      <button data-subreddit="jobsearchhacks" class="subreddit-tab flex-shrink-0 px-4 py-2 rounded-full text-sm font-medium transition-all bg-cream-100 text-ink-600 hover:bg-orange-100 hover:text-orange-700">
        jobsearchhacks
      </button>
    </div>

    <!-- Compact Filters -->
    <div id="filters-container" class="bg-white border border-cream-200 rounded-xl p-3 mb-6">
      <div class="flex flex-wrap items-center gap-3">
        <!-- Search -->
        <div class="flex-1 min-w-[200px]">
          <input
            type="text"
            id="search-input"
            placeholder="Search..."
            class="w-full px-3 py-1.5 text-sm border border-cream-200 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-accent/20 focus:border-accent"
          />
        </div>

        <!-- Quick filters -->
        <div class="flex items-center gap-2">
          <button id="filter-high-btn" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-amber-100 hover:text-amber-700 transition-all">
            ‚≠ê High
          </button>
          <button id="filter-saved-btn" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-rose-100 hover:text-rose-700 transition-all">
            ‚ô• Saved <span id="saved-count" class="opacity-70">(0)</span>
          </button>
          <button id="filter-unread-btn" class="filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-accent/10 hover:text-accent transition-all">
            ‚óè Unread
          </button>
        </div>

        <!-- Hidden toggle -->
        <button id="filter-hidden-btn" class="hidden filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-400 hover:bg-ink-100 transition-all">
          Show Hidden <span id="hidden-count">(0)</span>
        </button>

        <!-- Count -->
        <div class="text-sm text-ink-500">
          <span id="visible-count">0</span> items
        </div>
      </div>
    </div>

    <!-- Hidden legacy elements for JS compatibility -->
    <select id="filter-source" class="hidden"><option value="all">All</option></select>
    <select id="filter-category" class="hidden"><option value="all">All</option></select>
    <input type="checkbox" id="filter-high" class="hidden" />
    <input type="checkbox" id="filter-saved" class="hidden" />
    <input type="checkbox" id="filter-show-hidden" class="hidden" />
    <span id="show-hidden-label" class="hidden"></span>

    <!-- Batch actions bar (hidden by default) -->
    <div id="batch-actions" class="hidden bg-accent/5 border border-accent/20 rounded-xl p-4 mb-6">
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-3">
          <input type="checkbox" id="select-all" class="w-4 h-4 rounded border-cream-300 text-accent focus:ring-accent/20" />
          <span class="text-sm text-ink-700"><span id="selected-count">0</span> selected</span>
        </div>
        <div class="flex items-center gap-2">
          <button
            id="batch-save"
            type="button"
            class="px-3 py-1.5 text-sm font-medium bg-rose-100 text-rose-700 rounded-lg hover:bg-rose-200 transition-colors flex items-center gap-1"
          >
            <span>‚ô•</span> Save All
          </button>
          <button
            id="batch-hide"
            type="button"
            class="px-3 py-1.5 text-sm font-medium bg-ink-100 text-ink-600 rounded-lg hover:bg-ink-200 transition-colors flex items-center gap-1"
          >
            <span>‚úï</span> Hide All
          </button>
          <button
            id="batch-clear"
            type="button"
            class="px-3 py-1.5 text-sm font-medium text-ink-500 rounded-lg hover:bg-cream-100 transition-colors"
          >
            Clear
          </button>
        </div>
      </div>
    </div>

    <!-- X Content (hidden by default, shown when X tab is active) -->
    <!-- Content dynamically rendered via client-side fetch -->
    <div id="x-container" class="hidden">
      <!-- X Filters -->
      <div id="x-filters-container" class="bg-white border border-cream-200 rounded-xl p-3 mb-6">
        <div class="flex flex-wrap items-center gap-3">
          <!-- Search -->
          <div class="flex-1 min-w-[200px]">
            <input
              type="text"
              id="x-search-input"
              placeholder="Search tweets..."
              class="w-full px-3 py-1.5 text-sm border border-cream-200 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-sky-500/20 focus:border-sky-500"
            />
          </div>

          <!-- Quick filters -->
          <div class="flex items-center gap-2">
            <button id="x-filter-high-btn" class="x-filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-amber-100 hover:text-amber-700 transition-all">
              ‚≠ê High
            </button>
            <button id="x-filter-saved-btn" class="x-filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-rose-100 hover:text-rose-700 transition-all">
              ‚ô• Saved <span id="x-saved-count" class="opacity-70">(0)</span>
            </button>
            <button id="x-filter-unread-btn" class="x-filter-btn px-3 py-1.5 text-xs font-medium rounded-lg bg-cream-100 text-ink-600 hover:bg-sky-100 hover:text-sky-700 transition-all">
              ‚óè Unread
            </button>
          </div>

          <!-- Count -->
          <div class="text-sm text-ink-500">
            <span id="x-visible-count">0</span> items
          </div>
        </div>
      </div>

      <div id="x-items-wrapper" class="space-y-6">
        <!-- X items rendered here by JavaScript -->
      </div>
      <div id="x-empty-state" class="hidden text-center py-12">
        <div class="text-4xl mb-4">ùïè</div>
        <h3 class="text-lg font-medium text-ink-700 mb-2">No X data available</h3>
        <p class="text-sm text-ink-500">X data will be loaded from API.</p>
      </div>
    </div>

    <!-- Items grid (Reddit/HN/PH) -->
    <!-- Content dynamically rendered via client-side fetch -->
    <div id="items-container" class="grid gap-4 md:grid-cols-2">
      <!-- Items rendered here by JavaScript -->
    </div>

    <!-- Empty state for saved -->
    <div id="empty-saved" class="hidden text-center py-12">
      <div class="text-4xl mb-4">‚ô°</div>
      <h3 class="text-lg font-medium text-ink-700 mb-2">No saved items yet</h3>
      <p class="text-sm text-ink-500 mb-4">ÈªûÊìäÊ®ôÈ°åÊü•ÁúãÂàÜÊûêÔºåÁÑ∂ÂæåÊåâ ‚ô• Êî∂Ëóè ‰ª•‰øùÂ≠òÈ†ÖÁõÆ„ÄÇ</p>
      <button id="back-to-all" class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors">
        ‚Üê Back to All Items
      </button>
    </div>

    <!-- Empty state for no results -->
    <div id="empty-results" class="hidden text-center py-12">
      <div class="text-4xl mb-4">üîç</div>
      <h3 class="text-lg font-medium text-ink-700 mb-2">No items found</h3>
      <p class="text-sm text-ink-500">Try adjusting your filters or search term.</p>
    </div>

    <!-- Loading state (always shown initially, hidden after data loads) -->
    <div id="loading-state" class="text-center py-12">
      <div class="flex items-center justify-center">
        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-accent"></div>
        <span class="ml-3 text-ink-500">Loading from API...</span>
      </div>
    </div>
  </div>

  <!-- Analysis Modal -->
  <div id="analysis-modal" class="fixed inset-0 z-50 hidden">
    <div class="absolute inset-0 bg-black/50 backdrop-blur-sm" id="modal-backdrop"></div>
    <div class="absolute inset-4 md:inset-auto md:top-1/2 md:left-1/2 md:-translate-x-1/2 md:-translate-y-1/2 md:w-full md:max-w-2xl md:max-h-[80vh] bg-white rounded-xl shadow-2xl overflow-hidden flex flex-col">
      <!-- Modal header -->
      <div class="flex items-center justify-between p-4 border-b border-cream-200">
        <h2 class="text-lg font-semibold text-ink-900" id="modal-title">AI Analysis</h2>
        <button id="modal-close" class="p-2 hover:bg-cream-100 rounded-lg transition-colors">
          <svg class="w-5 h-5 text-ink-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      <!-- Modal content -->
      <div class="flex-1 overflow-y-auto p-4" id="modal-content">
        <div class="flex items-center justify-center py-8">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-accent"></div>
          <span class="ml-3 text-ink-500">Analyzing...</span>
        </div>
      </div>
      <!-- Modal footer -->
      <div class="p-4 border-t border-cream-200 flex items-center gap-2">
        <button id="modal-hide" class="px-3 py-2 text-sm font-medium text-red-600 hover:bg-red-50 rounded-lg transition-colors flex items-center gap-1">
          <span>üóëÔ∏è</span> Èö±Ëóè
        </button>
        <button id="modal-save" class="px-3 py-2 text-sm font-medium text-rose-600 hover:bg-rose-50 rounded-lg transition-colors flex items-center gap-1">
          <span>‚ô•</span> Êî∂Ëóè
        </button>
        <div class="flex-1"></div>
        <button id="modal-copy" class="px-3 py-2 text-sm font-medium text-ink-600 hover:bg-cream-100 rounded-lg transition-colors">
          üìã Copy
        </button>
        <a id="modal-open" href="#" target="_blank" rel="noreferrer noopener" class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors">
          Open ‚Üó
        </a>
      </div>
    </div>
  </div>
</BaseLayout>

<script>
  // Panopticon - Data loaded from azure_container API
  // Reference: Cockpit/ideas/panopticon-db-architecture-plan.md (Phase 4)

  // API Configuration
  const API_BASE = 'https://airesumeadvisor-api-production.calmisland-ea7fe91e.japaneast.azurecontainerapps.io/api/v1/panopticon';

  // HTML escape function to prevent XSS
  function escapeHtml(str: string): string {
    if (!str) return '';
    const escapeMap: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return str.replace(/[&<>"']/g, c => escapeMap[c] || c);
  }

  // Store items data globally for pre-computed analysis lookup
  (window as any).__PANOPTICON_ITEMS__ = {};

  // Types
  interface AnalysisResult {
    // Community items (Reddit, HN, PH)
    summary_zh?: string;
    why_popular?: string;
    response_angles?: string[];
    categories?: string[];
    fb_score?: number;
    blog_score?: number;
    // X items (Twitter)
    translation?: string;
    summary?: string;
    context_explanation?: string;
    motivation?: string;
    investment_signal?: string;
    title_ideas?: string[];
    angles?: {
      contrarian?: string[];
      conventional?: string[];
    };
  }

  interface ItemData {
    id: string;
    title: string;
    url: string;
    source: string;
    subreddit?: string;
    category?: string;
    selftext: string;
    score: number;
    comments: number;
    fbPotential: string;
    blogPotential: string;
  }

  interface PanopticonPrefs {
    saved: string[];
    hidden: string[];
    viewed: string[];
  }

  // localStorage keys
  const ANALYSIS_CACHE_KEY = 'panopticon-analysis-cache';
  const PREFS_KEY = 'panopticon-prefs';

  // Get/set preferences
  function getPrefs(): PanopticonPrefs {
    try {
      const stored = localStorage.getItem(PREFS_KEY);
      if (stored) {
        const prefs = JSON.parse(stored);
        // Ensure viewed array exists (backwards compatibility)
        if (!prefs.viewed) prefs.viewed = [];
        return prefs;
      }
    } catch {}
    return { saved: [], hidden: [], viewed: [] };
  }

  function setPrefs(prefs: PanopticonPrefs) {
    try {
      localStorage.setItem(PREFS_KEY, JSON.stringify(prefs));
    } catch (e) {
      console.error('Failed to save prefs:', e);
    }
  }

  function getCachedAnalysis(itemId: string): AnalysisResult | null {
    try {
      const cache = JSON.parse(localStorage.getItem(ANALYSIS_CACHE_KEY) || '{}');
      return cache[itemId] || null;
    } catch {
      return null;
    }
  }

  function setCachedAnalysis(itemId: string, analysis: AnalysisResult) {
    try {
      const cache = JSON.parse(localStorage.getItem(ANALYSIS_CACHE_KEY) || '{}');
      cache[itemId] = analysis;
      localStorage.setItem(ANALYSIS_CACHE_KEY, JSON.stringify(cache));
    } catch (e) {
      console.error('Failed to cache analysis:', e);
    }
  }

  // Current item being analyzed
  let currentItem: ItemData | null = null;
  let currentAnalysis: AnalysisResult | null = null;

  // Source display config
  const sourceConfig: Record<string, { label: string; color: string }> = {
    reddit: { label: 'Reddit', color: 'bg-orange-100 text-orange-700' },
    hackernews: { label: 'HN', color: 'bg-amber-100 text-amber-700' },
    producthunt: { label: 'PH', color: 'bg-red-100 text-red-700' },
  };

  // Potential badge colors
  const potentialColors: Record<string, string> = {
    High: 'bg-green-100 text-green-700',
    Medium: 'bg-yellow-100 text-yellow-700',
    Low: 'bg-gray-100 text-gray-500',
  };

  // X Category config
  const xCategoryConfig: Record<string, { label: string; color: string; bgColor: string }> = {
    ai_tech: { label: 'AI & Tech', color: 'text-purple-700', bgColor: 'bg-purple-50 border-purple-200' },
    indie_hacker: { label: 'Indie Hacker', color: 'text-green-700', bgColor: 'bg-green-50 border-green-200' },
    business: { label: 'Business & Politics', color: 'text-blue-700', bgColor: 'bg-blue-50 border-blue-200' },
    startup: { label: 'Startup & Investment', color: 'text-amber-700', bgColor: 'bg-amber-50 border-amber-200' },
    career: { label: 'Career', color: 'text-pink-700', bgColor: 'bg-pink-50 border-pink-200' },
    philosophy: { label: 'Philosophy & Mindset', color: 'text-indigo-700', bgColor: 'bg-indigo-50 border-indigo-200' },
    claude_code: { label: 'Claude Code', color: 'text-orange-700', bgColor: 'bg-orange-50 border-orange-200' },
  };

  // KOL descriptions - one-liner intro for each author
  const kolDescriptions: Record<string, string> = {
    'levelsio': 'Áç®Á´ãÈñãÁôºËÄÖÂÇ≥Â•áÔºåPhotoAI/Nomad List ÂâµËæ¶‰∫∫ÔºåÊï∏‰ΩçÈÅäÁâßÁîüÊ¥ªÂÄ°Â∞éËÄÖ',
    'bcherny': 'Anthropic Â∑•Á®ãÂ∏´ÔºåClaude Code ÂâµÂª∫ËÄÖ',
    'elonmusk': 'Tesla/SpaceX/X CEOÔºåÁßëÊäÄÁãÇ‰∫∫ËàáÁà≠Ë≠∞È†òË¢ñ',
    'nntaleb': '„ÄäÈªëÂ§©Èµù„Äã‰ΩúËÄÖÔºåÈ¢®Èö™ÁÆ°ÁêÜÂ∞àÂÆ∂ÔºåÂèçËÑÜÂº±ÊÄùÁ∂≠ÂÄ°Â∞éËÄÖ',
    'SahilBloom': 'ÂâµÊ•≠ÂÆ∂ËàáÂÖßÂÆπÂâµ‰ΩúËÄÖÔºåÂ∞àÊ≥®ÂÄã‰∫∫ÊàêÈï∑ËàáË≤°ÂØåÊô∫ÊÖß',
    'paulg': 'Y Combinator ÂÖ±ÂêåÂâµËæ¶‰∫∫ÔºåÂâµÊ•≠ÊïôÁà∂',
    'naval': 'AngelList ÂâµËæ¶‰∫∫ÔºåÁüΩË∞∑Âì≤Â≠∏ÂÆ∂',
    'dhh': 'Ruby on Rails ÂâµÂª∫ËÄÖÔºåBasecamp CTOÔºåÁõ¥Ë®Ä‰∏çË´±ÁöÑÊäÄË°ìÈ†òË¢ñ',
    'patrickc': 'Stripe CEOÔºåÈáëËûçÁßëÊäÄÈù©Êñ∞ËÄÖ',
    'sama': 'OpenAI CEOÔºåAGI Êé®ÂãïËÄÖ',
    'balajis': 'Ââç a16z ÂêàÂ§•‰∫∫ÔºåNetwork State ‰ΩúËÄÖÔºåÂä†ÂØÜË≤®Âπ£ÂÄ°Â∞éËÄÖ',
    'pmarca': 'a16z ÂâµËæ¶‰∫∫ÔºåÁ∂≤ÊôØÂâµËæ¶‰∫∫ÔºåÁßëÊäÄÊäïË≥áÊïôÁà∂',
    'jason': 'CalacanisÔºåÈÄ£Á∫åÂâµÊ•≠ÂÆ∂ËàáÂ§©‰ΩøÊäïË≥á‰∫∫',
    'amasad': 'Replit CEOÔºåËÆìÁ®ãÂºèË®≠Ë®àÊ∞ë‰∏ªÂåñÁöÑÊé®ÂãïËÄÖ',
  };

  // Convert score (1-5) to potential label
  function scoreToPotential(score: number): string {
    if (score >= 4) return 'High';
    if (score >= 2) return 'Medium';
    return 'Low';
  }

  // Render a single item card HTML
  function renderItemCard(item: any): string {
    const source = item.source || 'reddit';
    const sourceInfo = sourceConfig[source] || sourceConfig.reddit;
    const subreddit = item.subreddit || '';
    const sourceLabel = source === 'reddit' && subreddit ? `r/${escapeHtml(subreddit)}` : sourceInfo.label;

    // Parse ai_analysis if it's a JSON string
    let aiAnalysis = item.ai_analysis;
    if (typeof aiAnalysis === 'string') {
      try {
        aiAnalysis = JSON.parse(aiAnalysis);
      } catch (e) {
        aiAnalysis = null;
      }
    }

    // Prefer ai_analysis scores over item-level potential
    const fbScore = aiAnalysis?.fb_score;
    const blogScore = aiAnalysis?.blog_score;
    const engagementScore = (fbScore && blogScore) ? Math.round((fbScore + blogScore) / 2) : (item.engagement_score || 1);
    const fbPotential = fbScore ? scoreToPotential(fbScore) : (item.fb_potential || 'Low');
    const blogPotential = blogScore ? scoreToPotential(blogScore) : (item.blog_potential || 'Low');
    const selftext = item.selftext || '';
    const truncatedText = selftext.length > 150 ? selftext.slice(0, 150) + '...' : selftext;

    return `
      <div
        class="item-card bg-white border border-cream-200 rounded-xl p-5 hover:shadow-md hover:border-accent/30 transition-all"
        data-source="${escapeHtml(source)}"
        data-category="${escapeHtml(item.category || '')}"
        data-score="${engagementScore}"
        data-id="${escapeHtml(item.item_id || item.id || '')}"
        data-title="${escapeHtml(item.title || '')}"
        data-url="${escapeHtml(item.url || '')}"
        data-selftext="${escapeHtml(selftext)}"
        data-subreddit="${escapeHtml(subreddit)}"
        data-points="${item.score || 0}"
        data-comments="${item.comments || 0}"
        data-fb-potential="${escapeHtml(fbPotential)}"
        data-blog-potential="${escapeHtml(blogPotential)}"
        style="border-left: 3px solid var(--color-accent, #d97706);"
      >
        <div class="flex items-start justify-between gap-3 mb-3">
          <div class="flex items-center gap-2 flex-wrap">
            <input type="checkbox" class="card-checkbox w-4 h-4 rounded border-cream-300 text-accent focus:ring-accent/20 cursor-pointer" title="Select for batch action" />
            ${engagementScore >= 4 ? '<span class="text-amber-500" title="High engagement">‚≠ê</span>' : ''}
            <span class="px-2 py-0.5 text-xs font-medium rounded-full ${sourceInfo.color}">${sourceLabel}</span>
            <span class="text-xs text-ink-400">${item.score || 0} pts ¬∑ ${item.comments || 0} comments</span>
          </div>
          <span class="saved-indicator hidden text-rose-500 text-sm" title="Saved">‚ô•</span>
        </div>
        <h3 class="card-title text-base font-bold text-ink-900 mb-2 line-clamp-2 cursor-pointer hover:text-accent transition-colors">
          ${escapeHtml(item.title || '')}
        </h3>
        ${truncatedText ? `<p class="text-sm text-ink-500 mb-3 line-clamp-3">${escapeHtml(truncatedText)}</p>` : ''}
        <div class="flex items-center gap-2 mb-4 text-xs">
          <span class="px-2 py-0.5 rounded-full ${potentialColors[fbPotential] || potentialColors.Low}">FB: ${escapeHtml(fbPotential)}</span>
          <span class="px-2 py-0.5 rounded-full ${potentialColors[blogPotential] || potentialColors.Low}">Blog: ${escapeHtml(blogPotential)}</span>
          <span class="px-2 py-0.5 rounded-full ${potentialColors[scoreToPotential(engagementScore)] || potentialColors.Low}">Score: ${engagementScore}/5</span>
        </div>
      </div>
    `;
  }

  // Render X item HTML
  // API returns: likes, retweets, replies, views directly (not nested in metrics)
  function renderXItem(item: any): string {
    const engagementScore = item.engagement_score || 1;
    // API returns flat fields: likes, retweets, etc.
    const likes = item.likes || 0;
    const retweets = item.retweets || 0;
    const itemId = item.id || item.item_id || '';

    // Truncate text for preview (show first ~200 chars)
    const originalText = item.original_text || '';
    const previewText = originalText.length > 200
      ? originalText.slice(0, 200) + '...'
      : originalText;

    return `
      <div class="x-item bg-white rounded-lg p-5 border border-gray-100 cursor-pointer hover:bg-gray-50 hover:border-gray-200 transition-colors"
           data-x-id="${escapeHtml(itemId)}"
           data-url="${escapeHtml(item.url || '')}"
           data-author="${escapeHtml(item.author || '')}">
        <div class="flex items-start justify-between mb-3">
          <div class="flex items-center gap-2">
            ${engagementScore >= 4 ? '<span class="text-amber-500">‚≠ê</span>' : ''}
            <span class="text-sm text-gray-500">${likes} ‚ù§Ô∏è ¬∑ ${retweets} üîÅ</span>
          </div>
          <a href="${escapeHtml(item.url || '#')}" target="_blank" rel="noopener noreferrer"
             class="text-sky-500 hover:text-sky-600 x-external-link"
             onclick="event.stopPropagation()">‚Üó</a>
        </div>
        <p class="text-base text-gray-700 whitespace-pre-wrap x-item-text">${escapeHtml(previewText)}</p>
        <p class="text-sm text-sky-500 mt-3 hover:underline">ÈªûÊìäÊü•Áúã AI ÂàÜÊûê ‚Üí</p>
      </div>
    `;
  }

  // Render X category section
  // API returns: author, author_name, category
  function renderXCategory(category: string, items: any[]): string {
    const config = xCategoryConfig[category] || { label: category, color: 'text-gray-700', bgColor: 'bg-gray-50 border-gray-200' };

    // Group by author
    const byAuthor: Record<string, { authorName: string; items: any[] }> = {};
    items.forEach(item => {
      const author = item.author || 'unknown';
      if (!byAuthor[author]) {
        byAuthor[author] = { authorName: item.author_name || author, items: [] };
      }
      byAuthor[author].items.push(item);
    });

    const authorSections = Object.entries(byAuthor).map(([author, data]) => {
      const kolDesc = kolDescriptions[author] || '';
      return `
        <div class="x-kol-group mb-6" data-kol="${author}">
          <div class="mb-3">
            <h3 class="text-sm font-semibold flex items-center gap-2">
              <span class="text-gray-700">@${author}</span>
              <span class="text-xs text-gray-500 font-normal">${data.authorName}</span>
            </h3>
            ${kolDesc ? `<p class="text-xs text-gray-500 mt-1 pl-1">${escapeHtml(kolDesc)}</p>` : ''}
          </div>
          <div class="space-y-3 pl-4 border-l-2 border-gray-200">
            ${data.items.map(item => renderXItem(item)).join('')}
          </div>
        </div>
      `;
    }).join('');

    return `
      <section class="x-category-section mb-8 rounded-xl border p-4 ${config.bgColor}" data-x-category="${category}">
        <h2 class="text-lg font-bold mb-4 flex items-center gap-2 ${config.color}">
          <span>${config.label}</span>
          <span class="text-sm font-normal opacity-70">(${items.length} tweets from ${Object.keys(byAuthor).length} KOLs)</span>
        </h2>
        <div class="space-y-6">${authorSections}</div>
      </section>
    `;
  }

  // Fetch and render data from API
  async function loadDataFromAPI() {
    const loadingEl = document.getElementById('loading-state');
    const container = document.getElementById('items-container');
    const xContainer = document.getElementById('x-container');
    const xWrapper = document.getElementById('x-items-wrapper');
    const xEmptyState = document.getElementById('x-empty-state');
    const dateDisplay = document.getElementById('date-display');

    try {
      // Fetch both content and X data in parallel (GET endpoints, no API key needed)
      const [contentRes, xRes] = await Promise.all([
        fetch(`${API_BASE}/latest?source=content`),
        fetch(`${API_BASE}/latest?source=x`)
      ]);

      const contentData = await contentRes.json();
      const xData = await xRes.json();

      // Update date display
      if (dateDisplay && contentData.success) {
        const batch = contentData.data?.batch;
        dateDisplay.textContent = batch?.date || 'Today';
      }

      // Render content items
      if (contentData.success && contentData.data?.items?.length > 0) {
        const items = contentData.data.items;

        // Store items for analysis lookup
        (window as any).__PANOPTICON_ITEMS__ = items.reduce((acc: any, item: any) => {
          acc[item.item_id || item.id] = item;
          return acc;
        }, {});

        // Render HTML
        if (container) {
          container.innerHTML = items.map((item: any) => renderItemCard(item)).join('');
        }

        // Update stats - count from actual items
        updateStatsCounts(items);

        // Track loaded content IDs
        loadedContentIds = new Set(items.map((item: any) => item.item_id || item.id));
      }

      // Render X items
      if (xData.success && xData.data?.items?.length > 0) {
        const items = xData.data.items;
        const categoryOrder = ['ai_tech', 'indie_hacker', 'business', 'startup', 'career', 'philosophy', 'claude_code'];

        // Store X items for modal lookup
        (window as any).__PANOPTICON_X_ITEMS__ = items.reduce((acc: any, item: any) => {
          acc[item.id || item.item_id] = item;
          return acc;
        }, {});

        // Group by category
        const byCategory: Record<string, any[]> = {};
        items.forEach((item: any) => {
          const cat = item.category || 'other';
          if (!byCategory[cat]) byCategory[cat] = [];
          byCategory[cat].push(item);
        });

        // Render in order
        const xHtml = categoryOrder
          .filter(cat => byCategory[cat]?.length > 0)
          .map(cat => renderXCategory(cat, byCategory[cat]))
          .join('');

        if (xWrapper) {
          xWrapper.innerHTML = xHtml;
        }
        if (xEmptyState) {
          xEmptyState.classList.add('hidden');
        }

        // Update X stats
        updateXStatsCounts(items.length, items);

        // Track loaded X IDs
        loadedXIds = new Set(items.map((item: any) => item.id || item.item_id));
      } else {
        if (xEmptyState) {
          xEmptyState.classList.remove('hidden');
        }
      }

      // Hide loading, show content
      if (loadingEl) loadingEl.style.display = 'none';

    } catch (error) {
      console.error('Failed to load Panopticon data:', error);
      if (loadingEl) {
        loadingEl.innerHTML = `
          <div class="text-center py-12">
            <p class="text-red-500 mb-2">Failed to load data from API</p>
            <p class="text-sm text-ink-500 mb-4">${error}</p>
            <button onclick="loadDataFromAPI()" class="px-4 py-2 text-sm font-medium bg-accent text-white rounded-lg hover:bg-accent/90 transition-colors">
              Retry
            </button>
          </div>
        `;
      }
    }
  }

  // Store counts for computing total
  let contentItemsCount = 0;
  let xItemsCount = 0;

  // Track which item IDs are already loaded in DOM
  let loadedContentIds: Set<string> = new Set();
  let loadedXIds: Set<string> = new Set();

  // Fetch saved items by IDs from API (for historical saved items not in current batch)
  async function fetchSavedItemsByIds(ids: string[], source: 'content' | 'x'): Promise<any[]> {
    if (!ids.length) return [];
    try {
      const idsParam = ids.join(',');
      const res = await fetch(`${API_BASE}/items?ids=${encodeURIComponent(idsParam)}&source=${source}`);
      const data = await res.json();
      if (data.success && data.data?.items) {
        return data.data.items;
      }
    } catch (e) {
      console.error('Failed to fetch saved items:', e);
    }
    return [];
  }

  // Update stats counts in the source tabs
  function updateStatsCounts(items: any[]) {
    contentItemsCount = items.length;

    // Count by source from actual items
    const sourceCounts: Record<string, number> = { reddit: 0, hackernews: 0, producthunt: 0 };
    items.forEach(item => {
      const source = item.source || 'reddit';
      if (sourceCounts[source] !== undefined) {
        sourceCounts[source]++;
      }
    });

    // Update primary tab (Community count)
    const communityCountEl = document.getElementById('community-count-primary');
    if (communityCountEl) communityCountEl.textContent = String(items.length);

    // Update secondary source tabs
    const tabs = document.querySelectorAll('.source-tab');
    tabs.forEach(tab => {
      const source = (tab as HTMLElement).dataset.source;
      const countSpan = tab.querySelector('span');
      if (countSpan) {
        if (source === 'all') countSpan.textContent = String(items.length);
        else if (source === 'reddit') countSpan.textContent = String(sourceCounts.reddit);
        else if (source === 'hackernews') countSpan.textContent = String(sourceCounts.hackernews);
        else if (source === 'producthunt') countSpan.textContent = String(sourceCounts.producthunt);
      }
    });
  }

  // Store X category counts
  let xCategoryCounts: Record<string, number> = {};

  function updateXStatsCounts(count: number, items?: any[]) {
    xItemsCount = count;
    // Update primary tab (X count)
    const xCountEl = document.getElementById('x-count-primary');
    if (xCountEl) xCountEl.textContent = String(count);

    // Update X visible count (filter bar)
    const xVisibleCountEl = document.getElementById('x-visible-count');
    if (xVisibleCountEl) xVisibleCountEl.textContent = String(count);

    // Update X saved count
    const xSavedCountEl = document.getElementById('x-saved-count');
    if (xSavedCountEl && items) {
      const prefs = getPrefs();
      const savedXCount = items.filter((item: any) => prefs.saved.includes(item.id || item.item_id)).length;
      xSavedCountEl.textContent = `(${savedXCount})`;
    }

    // Initialize X items viewed state
    if (items) {
      const prefs = getPrefs();
      document.querySelectorAll('.x-item').forEach((el) => {
        const itemId = (el as HTMLElement).dataset.xId || '';
        if (prefs.viewed.includes(itemId)) {
          el.classList.add('is-viewed');
        }
      });
    }

    // Update X category tab counts
    if (items) {
      xCategoryCounts = {};
      items.forEach((item: any) => {
        const cat = item.category || 'other';
        xCategoryCounts[cat] = (xCategoryCounts[cat] || 0) + 1;
      });

      // Update each category tab count
      document.querySelectorAll('.x-cat-tab').forEach((tab) => {
        const t = tab as HTMLElement;
        const cat = t.dataset.xCat;
        const countSpan = t.querySelector('span');
        if (countSpan && cat) {
          if (cat === 'all') {
            countSpan.textContent = String(count);
          } else {
            countSpan.textContent = String(xCategoryCounts[cat] || 0);
          }
        }
      });
    }
  }

  function initPanopticon() {
    const container = document.getElementById('items-container');
    const sourceFilter = document.getElementById('filter-source') as HTMLSelectElement;
    const categoryFilter = document.getElementById('filter-category') as HTMLSelectElement;
    const highOnlyFilter = document.getElementById('filter-high') as HTMLInputElement;
    const savedFilter = document.getElementById('filter-saved') as HTMLInputElement;
    const showHiddenFilter = document.getElementById('filter-show-hidden') as HTMLInputElement;
    const showHiddenLabel = document.getElementById('show-hidden-label');
    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const visibleCount = document.getElementById('visible-count');
    const savedCountEl = document.getElementById('saved-count');
    const hiddenCountEl = document.getElementById('hidden-count');
    const refreshBtn = document.getElementById('refresh-btn');
    const modal = document.getElementById('analysis-modal');
    const modalBackdrop = document.getElementById('modal-backdrop');
    const modalClose = document.getElementById('modal-close');
    const modalContent = document.getElementById('modal-content');
    const modalTitle = document.getElementById('modal-title');
    const modalCopy = document.getElementById('modal-copy');
    const modalHide = document.getElementById('modal-hide');
    const modalSave = document.getElementById('modal-save');
    const modalOpen = document.getElementById('modal-open') as HTMLAnchorElement;
    const batchActions = document.getElementById('batch-actions');
    const selectAll = document.getElementById('select-all') as HTMLInputElement;
    const selectedCountEl = document.getElementById('selected-count');
    const batchSave = document.getElementById('batch-save');
    const batchHide = document.getElementById('batch-hide');
    const batchClear = document.getElementById('batch-clear');
    const emptySaved = document.getElementById('empty-saved');
    const emptyResults = document.getElementById('empty-results');
    const backToAll = document.getElementById('back-to-all');

    // New UI elements
    const sourceTabs = document.getElementById('source-tabs');
    const subredditTabs = document.getElementById('subreddit-tabs');
    const filterHighBtn = document.getElementById('filter-high-btn');
    const filterSavedBtn = document.getElementById('filter-saved-btn');
    const filterUnreadBtn = document.getElementById('filter-unread-btn');
    const filterHiddenBtn = document.getElementById('filter-hidden-btn');

    // X filter elements
    const xSearchInput = document.getElementById('x-search-input') as HTMLInputElement;
    const xFilterHighBtn = document.getElementById('x-filter-high-btn');
    const xFilterSavedBtn = document.getElementById('x-filter-saved-btn');
    const xFilterUnreadBtn = document.getElementById('x-filter-unread-btn');
    const xVisibleCount = document.getElementById('x-visible-count');
    const xSavedCountEl = document.getElementById('x-saved-count');

    if (!container) return;

    let prefs = getPrefs();

    // Current filter state
    let currentSource = 'all';
    let currentSubreddit = 'all';
    let filterHigh = false;
    let filterSaved = false;
    let filterUnread = false;
    let filterShowHidden = false;

    // X filter state
    let xFilterHigh = false;
    let xFilterSaved = false;
    let xFilterUnread = false;
    let xSearchQuery = '';

    // Update counts
    function updateCounts() {
      if (savedCountEl) savedCountEl.textContent = `(${prefs.saved.length})`;
      if (hiddenCountEl) hiddenCountEl.textContent = `(${prefs.hidden.length})`;
      // Show hidden button if there are hidden items
      if (filterHiddenBtn) {
        filterHiddenBtn.classList.toggle('hidden', prefs.hidden.length === 0);
      }
    }

    // Apply saved/hidden/viewed states to cards
    function applyStates() {
      const cards = container!.querySelectorAll('.item-card');
      cards.forEach((card) => {
        const el = card as HTMLElement;
        const id = el.dataset.id || '';
        el.classList.toggle('is-saved', prefs.saved.includes(id));
        el.classList.toggle('is-hidden', prefs.hidden.includes(id));
        el.classList.toggle('is-viewed', prefs.viewed.includes(id));
      });
    }

    // Filter function
    function applyFilters() {
      const searchTerm = searchInput?.value.toLowerCase() || '';

      const cards = container!.querySelectorAll('.item-card');
      let count = 0;

      cards.forEach((card) => {
        const el = card as HTMLElement;
        const cardId = el.dataset.id || '';
        const cardSource = el.dataset.source;
        const cardSubreddit = el.dataset.subreddit || '';
        const cardScore = parseInt(el.dataset.score || '0', 10);
        const cardTitle = (el.dataset.title || '').toLowerCase();
        const cardSelftext = (el.dataset.selftext || '').toLowerCase();

        const isSaved = prefs.saved.includes(cardId);
        const isHidden = prefs.hidden.includes(cardId);
        const isViewed = prefs.viewed.includes(cardId);

        // When filterSaved is active, ignore source/subreddit filters to show all saved items
        const sourceMatch = filterSaved || currentSource === 'all' || cardSource === currentSource;
        const subredditMatch = filterSaved || currentSubreddit === 'all' || cardSubreddit === currentSubreddit;
        const scoreMatch = !filterHigh || cardScore >= 4;
        const searchMatch = !searchTerm || cardTitle.includes(searchTerm) || cardSelftext.includes(searchTerm);
        const savedMatch = !filterSaved || isSaved;
        const unreadMatch = !filterUnread || !isViewed;
        const hiddenMatch = filterShowHidden || !isHidden;

        if (sourceMatch && subredditMatch && scoreMatch && searchMatch && savedMatch && unreadMatch && hiddenMatch) {
          el.style.display = '';
          count++;
        } else {
          el.style.display = 'none';
        }
      });

      if (visibleCount) {
        visibleCount.textContent = count.toString();
      }

      // Show empty states
      const showSavedEmpty = filterSaved && prefs.saved.length === 0;
      const showNoResults = !showSavedEmpty && count === 0;

      emptySaved?.classList.toggle('hidden', !showSavedEmpty);
      emptyResults?.classList.toggle('hidden', !showNoResults);
      container!.classList.toggle('hidden', showSavedEmpty || showNoResults);

      updateSelectedCount();
    }

    // Update selected count
    function updateSelectedCount() {
      const checkboxes = container!.querySelectorAll('.card-checkbox:checked');
      const visibleChecked = Array.from(checkboxes).filter((cb) => {
        const card = (cb as HTMLElement).closest('.item-card') as HTMLElement;
        return card && card.style.display !== 'none';
      });
      const count = visibleChecked.length;

      if (selectedCountEl) selectedCountEl.textContent = count.toString();
      batchActions?.classList.toggle('hidden', count === 0);
    }

    // Helper: Update tab styles
    function updateSourceTabStyles() {
      sourceTabs?.querySelectorAll('.source-tab').forEach((tab) => {
        const t = tab as HTMLElement;
        const isActive = t.dataset.source === currentSource;
        t.classList.toggle('active', isActive);

        // Reset all to default styles first
        t.classList.remove('bg-accent', 'text-white', 'bg-orange-500', 'bg-amber-500', 'bg-red-500');

        if (isActive) {
          if (currentSource === 'all') {
            t.classList.add('bg-accent', 'text-white');
          } else if (currentSource === 'reddit') {
            t.classList.add('bg-orange-500', 'text-white');
            t.classList.remove('bg-orange-50', 'text-orange-700');
          } else if (currentSource === 'hackernews') {
            t.classList.add('bg-amber-500', 'text-white');
            t.classList.remove('bg-amber-50', 'text-amber-700');
          } else if (currentSource === 'producthunt') {
            t.classList.add('bg-red-500', 'text-white');
            t.classList.remove('bg-red-50', 'text-red-700');
          }
        } else {
          // Restore default colors
          if (t.dataset.source === 'reddit') {
            t.classList.add('bg-orange-50', 'text-orange-700');
          } else if (t.dataset.source === 'hackernews') {
            t.classList.add('bg-amber-50', 'text-amber-700');
          } else if (t.dataset.source === 'producthunt') {
            t.classList.add('bg-red-50', 'text-red-700');
          }
        }
      });
    }

    function updateSubredditTabStyles() {
      subredditTabs?.querySelectorAll('.subreddit-tab').forEach((tab) => {
        const t = tab as HTMLElement;
        const isActive = t.dataset.subreddit === currentSubreddit;
        t.classList.toggle('active', isActive);

        if (isActive) {
          t.classList.add('bg-orange-500', 'text-white');
          t.classList.remove('bg-cream-100', 'text-ink-600');
        } else {
          t.classList.remove('bg-orange-500', 'text-white');
          t.classList.add('bg-cream-100', 'text-ink-600');
        }
      });
    }

    function updateFilterBtnStyles() {
      filterHighBtn?.classList.toggle('bg-amber-200', filterHigh);
      filterHighBtn?.classList.toggle('text-amber-800', filterHigh);
      filterSavedBtn?.classList.toggle('bg-rose-200', filterSaved);
      filterSavedBtn?.classList.toggle('text-rose-800', filterSaved);
      filterUnreadBtn?.classList.toggle('bg-accent/20', filterUnread);
      filterUnreadBtn?.classList.toggle('text-accent', filterUnread);
      filterHiddenBtn?.classList.toggle('bg-ink-200', filterShowHidden);
    }

    // X container reference
    const xContainer = document.getElementById('x-container');
    const primaryTabs = document.getElementById('primary-tabs');
    const xCategoryTabs = document.getElementById('x-category-tabs');

    // Current primary tab state
    let currentPrimary = 'x'; // Default to X tab
    let currentXCategory = 'all'; // Current X category filter

    // X category tab colors config
    const xCatColors: Record<string, { active: string; inactive: string }> = {
      all: { active: 'bg-sky-500 text-white', inactive: 'bg-sky-50 text-sky-700' },
      ai_tech: { active: 'bg-purple-500 text-white', inactive: 'bg-purple-50 text-purple-700' },
      indie_hacker: { active: 'bg-green-500 text-white', inactive: 'bg-green-50 text-green-700' },
      business: { active: 'bg-blue-500 text-white', inactive: 'bg-blue-50 text-blue-700' },
      startup: { active: 'bg-amber-500 text-white', inactive: 'bg-amber-50 text-amber-700' },
      career: { active: 'bg-pink-500 text-white', inactive: 'bg-pink-50 text-pink-700' },
      philosophy: { active: 'bg-indigo-500 text-white', inactive: 'bg-indigo-50 text-indigo-700' },
      claude_code: { active: 'bg-orange-500 text-white', inactive: 'bg-orange-50 text-orange-700' },
    };

    // Update X category tab styles
    function updateXCategoryTabStyles() {
      xCategoryTabs?.querySelectorAll('.x-cat-tab').forEach((tab) => {
        const t = tab as HTMLElement;
        const cat = t.dataset.xCat || 'all';
        const isActive = cat === currentXCategory;
        const colors = xCatColors[cat] || xCatColors.all;

        // Reset all color classes
        t.className = 'x-cat-tab flex-shrink-0 px-4 py-2 rounded-lg text-sm font-medium transition-all';

        if (isActive) {
          t.classList.add(...colors.active.split(' '));
        } else {
          t.classList.add(...colors.inactive.split(' '), 'hover:opacity-80');
        }
      });
    }

    // Filter X categories
    function applyXCategoryFilter() {
      const sections = document.querySelectorAll('.x-category-section');
      sections.forEach((section) => {
        const el = section as HTMLElement;
        const cat = el.dataset.xCategory;
        if (currentXCategory === 'all' || cat === currentXCategory) {
          el.style.display = '';
        } else {
          el.style.display = 'none';
        }
      });
      // Apply additional filters after category filter
      applyXFilters();
    }

    // Apply X filters (search, high, saved, unread)
    function applyXFilters() {
      const xItems = document.querySelectorAll('.x-item');
      const xItemsStore = (window as any).__PANOPTICON_X_ITEMS__ || {};
      let visibleCount = 0;
      const query = xSearchQuery.toLowerCase().trim();

      // First, reset all sections and KOL groups based on category tab (not filters)
      const allSections = document.querySelectorAll('.x-category-section');
      allSections.forEach((section) => {
        const sectionEl = section as HTMLElement;
        const cat = sectionEl.dataset.xCategory || '';
        // Show section if "all" or matches current category tab
        const showByTab = currentXCategory === 'all' || cat === currentXCategory;
        sectionEl.style.display = showByTab ? '' : 'none';
        // Also reset all KOL groups inside
        sectionEl.querySelectorAll('.x-kol-group').forEach((g) => {
          (g as HTMLElement).style.display = showByTab ? '' : 'none';
        });
      });

      xItems.forEach((item) => {
        const el = item as HTMLElement;
        const itemId = el.dataset.xId || '';
        const storedItem = xItemsStore[itemId];
        const section = el.closest('.x-category-section') as HTMLElement;

        // Skip if section is hidden by category TAB (not by filter)
        const cat = section?.dataset.xCategory || '';
        if (currentXCategory !== 'all' && cat !== currentXCategory) {
          return;
        }

        let show = true;

        // Search filter
        if (query && storedItem) {
          const text = (storedItem.original_text || '').toLowerCase();
          const author = (storedItem.author || '').toLowerCase();
          const authorName = (storedItem.author_name || '').toLowerCase();
          const translation = storedItem.analysis?.translation?.toLowerCase() || '';
          const summary = storedItem.analysis?.summary?.toLowerCase() || '';

          if (!text.includes(query) && !author.includes(query) && !authorName.includes(query) && !translation.includes(query) && !summary.includes(query)) {
            show = false;
          }
        }

        // High score filter (engagement_score >= 4)
        if (xFilterHigh && storedItem) {
          const score = storedItem.engagement_score || storedItem.analysis?.score || 0;
          if (score < 4) show = false;
        }

        // Saved filter
        if (xFilterSaved) {
          if (!prefs.saved.includes(itemId)) show = false;
        }

        // Unread filter (not in viewed list)
        if (xFilterUnread) {
          if (prefs.viewed.includes(itemId)) show = false;
        }

        // Apply visibility
        el.style.display = show ? '' : 'none';
        if (show) visibleCount++;
      });

      // Update visible count
      if (xVisibleCount) {
        xVisibleCount.textContent = String(visibleCount);
      }

      // Hide empty KOL groups (no visible items inside)
      // Only process groups in sections that are allowed by category tab
      const kolGroups = document.querySelectorAll('.x-kol-group');
      kolGroups.forEach((group) => {
        const groupEl = group as HTMLElement;
        const section = groupEl.closest('.x-category-section') as HTMLElement;
        const sectionCat = section?.dataset.xCategory || '';
        // Skip if section is hidden by category tab
        if (currentXCategory !== 'all' && sectionCat !== currentXCategory) {
          return;
        }
        const items = groupEl.querySelectorAll('.x-item');
        const hasVisible = Array.from(items).some((item) => (item as HTMLElement).style.display !== 'none');
        groupEl.style.display = hasVisible ? '' : 'none';
      });

      // Hide empty category sections (no visible KOL groups inside)
      // Only process sections that are allowed by category tab
      const categorySections = document.querySelectorAll('.x-category-section');
      categorySections.forEach((section) => {
        const sectionEl = section as HTMLElement;
        const sectionCat = sectionEl.dataset.xCategory || '';
        // Skip if section is hidden by category tab
        if (currentXCategory !== 'all' && sectionCat !== currentXCategory) {
          return;
        }
        const groups = sectionEl.querySelectorAll('.x-kol-group');
        const hasVisible = Array.from(groups).some((g) => (g as HTMLElement).style.display !== 'none');
        sectionEl.style.display = hasVisible ? '' : 'none';
      });

      // Update X saved count
      updateXCounts();
    }

    // Update X filter button styles
    function updateXFilterBtnStyles() {
      // High button
      if (xFilterHighBtn) {
        xFilterHighBtn.classList.toggle('bg-amber-100', xFilterHigh);
        xFilterHighBtn.classList.toggle('text-amber-700', xFilterHigh);
        xFilterHighBtn.classList.toggle('bg-cream-100', !xFilterHigh);
        xFilterHighBtn.classList.toggle('text-ink-600', !xFilterHigh);
      }
      // Saved button
      if (xFilterSavedBtn) {
        xFilterSavedBtn.classList.toggle('bg-rose-100', xFilterSaved);
        xFilterSavedBtn.classList.toggle('text-rose-700', xFilterSaved);
        xFilterSavedBtn.classList.toggle('bg-cream-100', !xFilterSaved);
        xFilterSavedBtn.classList.toggle('text-ink-600', !xFilterSaved);
      }
      // Unread button
      if (xFilterUnreadBtn) {
        xFilterUnreadBtn.classList.toggle('bg-sky-100', xFilterUnread);
        xFilterUnreadBtn.classList.toggle('text-sky-700', xFilterUnread);
        xFilterUnreadBtn.classList.toggle('bg-cream-100', !xFilterUnread);
        xFilterUnreadBtn.classList.toggle('text-ink-600', !xFilterUnread);
      }
    }

    // Update X counts (saved count in filter bar)
    function updateXCounts() {
      // Count saved X items
      const xItemsStore = (window as any).__PANOPTICON_X_ITEMS__ || {};
      const xItemIds = Object.keys(xItemsStore);
      const savedXCount = xItemIds.filter(id => prefs.saved.includes(id)).length;

      if (xSavedCountEl) {
        xSavedCountEl.textContent = `(${savedXCount})`;
      }
    }

    // Update primary tab styles
    function updatePrimaryTabStyles() {
      primaryTabs?.querySelectorAll('.primary-tab').forEach((tab) => {
        const t = tab as HTMLElement;
        const isActive = t.dataset.primary === currentPrimary;
        t.classList.toggle('active', isActive);

        // Reset styles
        t.classList.remove('bg-sky-500', 'text-white', 'shadow-sm', 'bg-accent', 'bg-cream-100', 'text-ink-600');

        if (isActive) {
          if (currentPrimary === 'x') {
            t.classList.add('bg-sky-500', 'text-white', 'shadow-sm');
          } else {
            t.classList.add('bg-accent', 'text-white', 'shadow-sm');
          }
        } else {
          t.classList.add('bg-cream-100', 'text-ink-600');
        }
      });
    }

    // Primary tab click handlers
    primaryTabs?.querySelectorAll('.primary-tab').forEach((tab) => {
      tab.addEventListener('click', () => {
        currentPrimary = (tab as HTMLElement).dataset.primary || 'x';
        currentSubreddit = 'all';

        if (currentPrimary === 'x') {
          // Show X content
          xContainer?.classList.remove('hidden');
          container?.classList.add('hidden');
          xCategoryTabs?.classList.remove('hidden');
          xCategoryTabs?.classList.add('flex');
          sourceTabs?.classList.add('hidden');
          sourceTabs?.classList.remove('flex');
          subredditTabs?.classList.add('hidden');
          subredditTabs?.classList.remove('flex');
          document.getElementById('filters-container')?.classList.add('hidden');
        } else {
          // Show Community content
          xContainer?.classList.add('hidden');
          container?.classList.remove('hidden');
          xCategoryTabs?.classList.add('hidden');
          xCategoryTabs?.classList.remove('flex');
          sourceTabs?.classList.remove('hidden');
          sourceTabs?.classList.add('flex');
          document.getElementById('filters-container')?.classList.remove('hidden');
          // Reset to 'all' source for community
          currentSource = 'all';
          updateSourceTabStyles();
          applyFilters();
        }

        updatePrimaryTabStyles();
      });
    });

    // X category tab click handlers
    xCategoryTabs?.querySelectorAll('.x-cat-tab').forEach((tab) => {
      tab.addEventListener('click', () => {
        currentXCategory = (tab as HTMLElement).dataset.xCat || 'all';
        updateXCategoryTabStyles();
        applyXCategoryFilter();
      });
    });

    // X filter button handlers
    xFilterHighBtn?.addEventListener('click', () => {
      xFilterHigh = !xFilterHigh;
      updateXFilterBtnStyles();
      applyXFilters();
    });

    xFilterSavedBtn?.addEventListener('click', async () => {
      xFilterSaved = !xFilterSaved;
      updateXFilterBtnStyles();

      // When activating Saved filter, fetch historical saved X items not in current batch
      if (xFilterSaved) {
        const xWrapper = document.getElementById('x-items-wrapper');
        const missingSavedIds = prefs.saved.filter(id => !loadedXIds.has(id));
        if (missingSavedIds.length > 0 && xWrapper) {
          // Fetch missing saved X items from API
          const historicalItems = await fetchSavedItemsByIds(missingSavedIds, 'x');
          if (historicalItems.length > 0) {
            // Group by category
            const byCategory: Record<string, any[]> = {};
            historicalItems.forEach((item: any) => {
              const cat = item.category || 'other';
              if (!byCategory[cat]) byCategory[cat] = [];
              byCategory[cat].push(item);
            });

            // For each category, either append to existing section or create new one
            const categoryOrder = ['ai_tech', 'indie_hacker', 'business', 'startup', 'career', 'philosophy', 'claude_code'];
            categoryOrder.forEach(cat => {
              if (!byCategory[cat]?.length) return;

              const existingSection = xWrapper.querySelector(`[data-x-category="${cat}"]`);
              if (existingSection) {
                // Append items to existing KOL groups or create new ones
                const spaceDiv = existingSection.querySelector('.space-y-6');
                if (spaceDiv) {
                  // Group new items by author
                  const byAuthor: Record<string, { authorName: string; items: any[] }> = {};
                  byCategory[cat].forEach(item => {
                    const author = item.author || 'unknown';
                    if (!byAuthor[author]) {
                      byAuthor[author] = { authorName: item.author_name || author, items: [] };
                    }
                    byAuthor[author].items.push(item);
                  });

                  Object.entries(byAuthor).forEach(([author, data]) => {
                    const existingKolGroup = spaceDiv.querySelector(`[data-kol="${author}"]`);
                    if (existingKolGroup) {
                      // Append to existing KOL group
                      const itemsContainer = existingKolGroup.querySelector('.space-y-3');
                      if (itemsContainer) {
                        const newItemsHtml = data.items.map(item => renderXItem(item)).join('');
                        itemsContainer.insertAdjacentHTML('beforeend', newItemsHtml);
                      }
                    } else {
                      // Create new KOL group
                      const kolDesc = kolDescriptions[author] || '';
                      const newKolHtml = `
                        <div class="x-kol-group mb-6" data-kol="${escapeHtml(author)}">
                          <div class="mb-3">
                            <h3 class="text-sm font-semibold flex items-center gap-2">
                              <span class="text-gray-700">@${escapeHtml(author)}</span>
                              <span class="text-xs text-gray-500 font-normal">${escapeHtml(data.authorName)}</span>
                            </h3>
                            ${kolDesc ? `<p class="text-xs text-gray-500 mt-1 pl-1">${escapeHtml(kolDesc)}</p>` : ''}
                          </div>
                          <div class="space-y-3 pl-4 border-l-2 border-gray-200">
                            ${data.items.map(item => renderXItem(item)).join('')}
                          </div>
                        </div>
                      `;
                      spaceDiv.insertAdjacentHTML('beforeend', newKolHtml);
                    }
                  });
                }
              } else {
                // Create new category section
                const newSectionHtml = renderXCategory(cat, byCategory[cat]);
                xWrapper.insertAdjacentHTML('beforeend', newSectionHtml);
              }
            });

            // Track newly loaded IDs
            historicalItems.forEach((item: any) => {
              const id = item.id || item.item_id;
              loadedXIds.add(id);
              // Store for modal lookup
              (window as any).__PANOPTICON_X_ITEMS__[id] = item;
            });
          }
        }
      }

      applyXFilters();
    });

    xFilterUnreadBtn?.addEventListener('click', () => {
      xFilterUnread = !xFilterUnread;
      updateXFilterBtnStyles();
      applyXFilters();
    });

    // X search input handler
    xSearchInput?.addEventListener('input', (e) => {
      xSearchQuery = (e.target as HTMLInputElement).value;
      applyXFilters();
    });

    // Source tab click handlers (secondary tabs for Community)
    sourceTabs?.querySelectorAll('.source-tab').forEach((tab) => {
      tab.addEventListener('click', () => {
        currentSource = (tab as HTMLElement).dataset.source || 'all';
        currentSubreddit = 'all'; // Reset subreddit when changing source

        // Show/hide subreddit tabs for Reddit
        if (currentSource === 'reddit') {
          subredditTabs?.classList.remove('hidden');
          subredditTabs?.classList.add('flex');
        } else {
          subredditTabs?.classList.add('hidden');
          subredditTabs?.classList.remove('flex');
        }

        updateSourceTabStyles();
        updateSubredditTabStyles();
        applyFilters();
      });
    });

    // Subreddit tab click handlers
    subredditTabs?.querySelectorAll('.subreddit-tab').forEach((tab) => {
      tab.addEventListener('click', () => {
        currentSubreddit = (tab as HTMLElement).dataset.subreddit || 'all';
        updateSubredditTabStyles();
        applyFilters();
      });
    });

    // Filter button handlers
    filterHighBtn?.addEventListener('click', () => {
      filterHigh = !filterHigh;
      updateFilterBtnStyles();
      applyFilters();
    });

    filterSavedBtn?.addEventListener('click', async () => {
      filterSaved = !filterSaved;
      updateFilterBtnStyles();

      // When activating Saved filter, fetch historical saved items not in current batch
      if (filterSaved) {
        const missingSavedIds = prefs.saved.filter(id => !loadedContentIds.has(id));
        if (missingSavedIds.length > 0) {
          // Fetch missing saved items from API
          const historicalItems = await fetchSavedItemsByIds(missingSavedIds, 'content');
          if (historicalItems.length > 0 && container) {
            // Append to container
            const newHtml = historicalItems.map((item: any) => renderItemCard(item)).join('');
            container.insertAdjacentHTML('beforeend', newHtml);
            // Track newly loaded IDs
            historicalItems.forEach((item: any) => {
              const id = item.item_id || item.id;
              loadedContentIds.add(id);
              // Store for analysis lookup
              (window as any).__PANOPTICON_ITEMS__[id] = item;
            });
            // Apply states to new cards
            applyStates();
          }
        }
      }

      applyFilters();
    });

    filterUnreadBtn?.addEventListener('click', () => {
      filterUnread = !filterUnread;
      updateFilterBtnStyles();
      applyFilters();
    });

    filterHiddenBtn?.addEventListener('click', () => {
      filterShowHidden = !filterShowHidden;
      updateFilterBtnStyles();
      applyFilters();
    });

    // Debounced search
    let searchTimeout: ReturnType<typeof setTimeout>;
    searchInput?.addEventListener('input', () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(applyFilters, 300);
    });

    // Back to all button
    backToAll?.addEventListener('click', () => {
      filterSaved = false;
      updateFilterBtnStyles();
      applyFilters();
    });

    // Checkbox handlers
    container.querySelectorAll('.card-checkbox').forEach((cb) => {
      cb.addEventListener('change', updateSelectedCount);
      cb.addEventListener('click', (e) => e.stopPropagation());
    });

    // Select all
    selectAll?.addEventListener('change', () => {
      const visibleCards = Array.from(container!.querySelectorAll('.item-card')).filter(
        (card) => (card as HTMLElement).style.display !== 'none'
      );
      visibleCards.forEach((card) => {
        const cb = card.querySelector('.card-checkbox') as HTMLInputElement;
        if (cb) cb.checked = selectAll.checked;
      });
      updateSelectedCount();
    });

    // Batch save
    batchSave?.addEventListener('click', () => {
      const checkedCards = container!.querySelectorAll('.item-card:has(.card-checkbox:checked)');
      checkedCards.forEach((card) => {
        const id = (card as HTMLElement).dataset.id || '';
        if (!prefs.saved.includes(id)) {
          prefs.saved.push(id);
        }
        // Uncheck
        const cb = card.querySelector('.card-checkbox') as HTMLInputElement;
        if (cb) cb.checked = false;
      });
      setPrefs(prefs);
      applyStates();
      updateCounts();
      updateSelectedCount();
    });

    // Batch hide
    batchHide?.addEventListener('click', () => {
      const checkedCards = container!.querySelectorAll('.item-card:has(.card-checkbox:checked)');
      checkedCards.forEach((card) => {
        const id = (card as HTMLElement).dataset.id || '';
        if (!prefs.hidden.includes(id)) {
          prefs.hidden.push(id);
        }
        // Uncheck
        const cb = card.querySelector('.card-checkbox') as HTMLInputElement;
        if (cb) cb.checked = false;
      });
      setPrefs(prefs);
      applyStates();
      updateCounts();
      applyFilters();
    });

    // Batch clear selection
    batchClear?.addEventListener('click', () => {
      container!.querySelectorAll('.card-checkbox').forEach((cb) => {
        (cb as HTMLInputElement).checked = false;
      });
      if (selectAll) selectAll.checked = false;
      updateSelectedCount();
    });

    // Initialize states
    applyStates();
    updateCounts();

    // Initialize with X tab selected (default)
    xContainer?.classList.remove('hidden');
    container?.classList.add('hidden');
    xCategoryTabs?.classList.remove('hidden');
    xCategoryTabs?.classList.add('flex');
    sourceTabs?.classList.add('hidden');
    sourceTabs?.classList.remove('flex');
    document.getElementById('filters-container')?.classList.add('hidden');
    updatePrimaryTabStyles();
    updateXCategoryTabStyles();

    // Refresh button - reload data from API
    refreshBtn?.addEventListener('click', async () => {
      const btn = refreshBtn as HTMLButtonElement;
      btn.disabled = true;
      btn.innerHTML = `
        <svg class="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
        Loading...
      `;

      try {
        await loadDataFromAPI();
        // Re-initialize UI after data reload
        prefs = getPrefs();
        applyStates();
        updateCounts();
        applyFilters();

        btn.innerHTML = `
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
          </svg>
          Done!
        `;
      } catch (e) {
        console.error('Refresh failed:', e);
        btn.innerHTML = `
          <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
          Failed
        `;
      } finally {
        setTimeout(() => {
          btn.disabled = false;
          btn.innerHTML = `
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            Refresh
          `;
        }, 2000);
      }
    });

    // Modal functions
    function openModal() {
      modal?.classList.remove('hidden');
      document.body.style.overflow = 'hidden';

      // Update modal button states based on saved/hidden status
      if (currentItem && modalSave && modalHide) {
        const isSaved = prefs.saved.includes(currentItem.id);
        const isHidden = prefs.hidden.includes(currentItem.id);

        // Update Save button style
        if (isSaved) {
          modalSave.className = 'px-3 py-2 text-sm font-medium text-white bg-rose-500 rounded-lg transition-colors flex items-center gap-1';
          modalSave.innerHTML = '<span>‚ô•</span> Â∑≤Êî∂Ëóè';
        } else {
          modalSave.className = 'px-3 py-2 text-sm font-medium text-rose-600 hover:bg-rose-50 rounded-lg transition-colors flex items-center gap-1';
          modalSave.innerHTML = '<span>‚ô•</span> Êî∂Ëóè';
        }

        // Update Hide button style
        if (isHidden) {
          modalHide.className = 'px-3 py-2 text-sm font-medium text-white bg-red-500 rounded-lg transition-colors flex items-center gap-1';
          modalHide.innerHTML = '<span>üóëÔ∏è</span> Â∑≤Èö±Ëóè';
        } else {
          modalHide.className = 'px-3 py-2 text-sm font-medium text-red-600 hover:bg-red-50 rounded-lg transition-colors flex items-center gap-1';
          modalHide.innerHTML = '<span>üóëÔ∏è</span> Èö±Ëóè';
        }
      }
    }

    function closeModal() {
      modal?.classList.add('hidden');
      document.body.style.overflow = '';
      currentItem = null;
      currentAnalysis = null;
    }

    function renderAnalysis(analysis: AnalysisResult) {
      if (!modalContent) return;

      const categoryLabels: Record<string, string> = {
        industry_thoughts: 'Ë°åÊ•≠ÊÄùËÄÉ',
        values: '‰∫∫ÁîüÂÉπÂÄºËßÄ',
        personal_growth: 'ÂÄã‰∫∫ÊàêÈï∑',
        achievements: '‰∫∫ÁîüÊàêÂ∞±',
        testimonials: 'ÂÆ¢Êà∂Ë≠âË®Ä',
      };

      // Get original English content from currentItem
      const originalTitle = currentItem?.title || '';
      const originalSelftext = currentItem?.selftext || '';

      modalContent.innerHTML = `
        <div class="space-y-4">
          <!-- English Original -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">üìÑ Ëã±ÊñáÂéüÊñá</h3>
            <div class="bg-cream-50 rounded-lg p-3 text-ink-800">
              <p class="font-medium mb-2">${originalTitle}</p>
              ${originalSelftext ? `<p class="text-sm text-ink-600 whitespace-pre-wrap">${originalSelftext}</p>` : '<p class="text-sm text-ink-400 italic">(ÁÑ°ÂÖßÂÆπ)</p>'}
            </div>
          </div>

          <!-- Chinese Summary -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">üìù ‰∏≠ÊñáÊëòË¶Å</h3>
            <p class="text-ink-900">${analysis.summary_zh}</p>
          </div>

          <!-- Why Popular -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">üî• ÁÇ∫‰ªÄÈ∫ºÂèóÊ≠°Ëøé</h3>
            <p class="text-ink-900">${analysis.why_popular}</p>
          </div>

          <!-- Response Angles (Collapsible) -->
          <div>
            <button id="toggle-angles" class="flex items-center gap-2 text-sm font-medium text-ink-500 hover:text-ink-700 transition-colors">
              <span>üí° ÂõûÊáâËßíÂ∫¶Âª∫Ë≠∞</span>
              <svg class="w-4 h-4 transform transition-transform" id="angles-arrow" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
              </svg>
            </button>
            <div id="angles-content" class="hidden mt-2">
              <ul class="list-disc list-inside text-ink-900 space-y-1 pl-2">
                ${(analysis.response_angles || []).map(a => `<li>${a}</li>`).join('')}
              </ul>
            </div>
          </div>

          <!-- Categories -->
          <div>
            <h3 class="text-sm font-medium text-ink-500 mb-1">üè∑Ô∏è ÂÖßÂÆπÂàÜÈ°û</h3>
            <div class="flex flex-wrap gap-2">
              ${(analysis.categories || []).map(c => `<span class="px-2 py-1 text-xs bg-cream-100 text-ink-700 rounded-full">${categoryLabels[c] || c}</span>`).join('')}
            </div>
          </div>

          <!-- Scores -->
          <div class="flex gap-6 pt-2">
            <div>
              <h3 class="text-sm font-medium text-ink-500 mb-1">FB ÈÅ©ÂêàÂ∫¶</h3>
              <div class="text-2xl font-bold text-accent">${analysis.fb_score}/5</div>
            </div>
            <div>
              <h3 class="text-sm font-medium text-ink-500 mb-1">Blog ÈÅ©ÂêàÂ∫¶</h3>
              <div class="text-2xl font-bold text-accent">${analysis.blog_score}/5</div>
            </div>
          </div>
        </div>
      `;

      // Add toggle handler for response angles
      const toggleBtn = document.getElementById('toggle-angles');
      const anglesContent = document.getElementById('angles-content');
      const anglesArrow = document.getElementById('angles-arrow');

      toggleBtn?.addEventListener('click', () => {
        anglesContent?.classList.toggle('hidden');
        anglesArrow?.classList.toggle('rotate-180');
      });
    }

    // Analyze button handlers (and title click)
    function handleAnalyze(card: HTMLElement) {
      const itemId = card.dataset.id || '';

      currentItem = {
        id: itemId,
        title: card.dataset.title || '',
        url: card.dataset.url || '',
        source: card.dataset.source || '',
        subreddit: card.dataset.subreddit,
        category: card.dataset.category,
        selftext: card.dataset.selftext || '',
        score: parseInt(card.dataset.points || '0', 10),
        comments: parseInt(card.dataset.comments || '0', 10),
        fbPotential: card.dataset.fbPotential || '',
        blogPotential: card.dataset.blogPotential || '',
      };

      // Mark as viewed
      if (!prefs.viewed.includes(itemId)) {
        prefs.viewed.push(itemId);
        setPrefs(prefs);
        card.classList.add('is-viewed');
      }

      // Set modal Open link
      if (modalOpen) {
        modalOpen.href = currentItem.url;
      }

      if (modalTitle) {
        modalTitle.textContent = currentItem.title.slice(0, 50) + (currentItem.title.length > 50 ? '...' : '');
      }

      // Check for pre-computed analysis from batch processing
      const itemsStore = (window as any).__PANOPTICON_ITEMS__ || {};
      const storedItem = itemsStore[itemId];
      if (storedItem?.ai_analysis) {
        // ai_analysis may be a JSON string, parse if needed
        let analysis = storedItem.ai_analysis;
        if (typeof analysis === 'string') {
          try {
            analysis = JSON.parse(analysis);
          } catch (e) {
            console.error('Failed to parse ai_analysis:', e);
          }
        }
        currentAnalysis = analysis;
        renderAnalysis(analysis);
        openModal();
        return;
      }

      // Check localStorage cache (for previously viewed analysis)
      const cached = getCachedAnalysis(itemId);
      if (cached) {
        currentAnalysis = cached;
        renderAnalysis(cached);
        openModal();
        return;
      }

      // No pre-computed analysis available - show message with original content
      if (modalContent) {
        const originalTitle = currentItem?.title || '';
        const originalSelftext = currentItem?.selftext || '';

        modalContent.innerHTML = `
          <div class="space-y-4">
            <div class="bg-amber-50 border border-amber-200 rounded-lg p-4">
              <p class="text-amber-800 text-sm">
                <strong>AI ÂàÜÊûêÂ∞öÊú™Ê∫ñÂÇôÂ•Ω</strong><br>
                Ê≠§È†ÖÁõÆÁöÑ AI ÂàÜÊûêÂ∞áÂú®‰∏ãÊ¨° batch ËôïÁêÜÊôÇÁîüÊàê„ÄÇ
              </p>
            </div>

            <div>
              <h3 class="text-sm font-medium text-ink-500 mb-1">üìÑ ÂéüÊñáÂÖßÂÆπ</h3>
              <div class="bg-cream-50 rounded-lg p-3 text-ink-800">
                <p class="font-medium mb-2">${escapeHtml(originalTitle)}</p>
                ${originalSelftext ? `<p class="text-sm text-ink-600 whitespace-pre-wrap">${escapeHtml(originalSelftext)}</p>` : '<p class="text-sm text-ink-400 italic">(ÁÑ°ÂÖßÂÆπ)</p>'}
              </div>
            </div>
          </div>
        `;
      }
      openModal();
    }

    // Handle X item analysis
    function handleXAnalyze(xItem: HTMLElement) {
      const itemId = xItem.dataset.xId || '';
      const xItemsStore = (window as any).__PANOPTICON_X_ITEMS__ || {};
      const storedItem = xItemsStore[itemId];

      if (!storedItem) {
        console.error('X item not found:', itemId);
        return;
      }

      // Parse analysis if it's a JSON string
      let analysis = storedItem.analysis;
      if (typeof analysis === 'string') {
        try {
          analysis = JSON.parse(analysis);
        } catch (e) {
          console.error('Failed to parse X analysis:', e);
          analysis = null;
        }
      }

      // Set current item for modal buttons
      currentItem = {
        id: itemId,
        title: `@${storedItem.author}: ${(storedItem.original_text || '').slice(0, 50)}...`,
        url: storedItem.url || '',
        source: 'x',
        selftext: storedItem.original_text || '',
        score: storedItem.engagement_score || 1,
        comments: storedItem.replies || 0,
        fbPotential: '',
        blogPotential: '',
      };

      // Update modal title
      if (modalTitle) {
        modalTitle.textContent = `@${storedItem.author}`;
      }

      // Set modal Open link
      if (modalOpen) {
        modalOpen.href = storedItem.url || '#';
      }

      // Render X analysis
      if (modalContent) {
        const kolDesc = kolDescriptions[storedItem.author] || '';
        const likes = storedItem.likes || 0;
        const retweets = storedItem.retweets || 0;
        const replies = storedItem.replies || 0;
        const views = storedItem.views || 0;

        modalContent.innerHTML = `
          <div class="space-y-4">
            <!-- Author Info -->
            <div class="bg-sky-50 rounded-lg p-3">
              <div class="flex items-center gap-2 mb-1">
                <span class="font-semibold text-sky-700">@${escapeHtml(storedItem.author)}</span>
                <span class="text-sm text-gray-600">${escapeHtml(storedItem.author_name || '')}</span>
              </div>
              ${kolDesc ? `<p class="text-xs text-gray-500">${escapeHtml(kolDesc)}</p>` : ''}
            </div>

            <!-- Engagement Stats -->
            <div class="flex gap-4 text-sm text-gray-600">
              <span>‚ù§Ô∏è ${likes.toLocaleString()}</span>
              <span>üîÅ ${retweets.toLocaleString()}</span>
              <span>üí¨ ${replies.toLocaleString()}</span>
              <span>üëÅÔ∏è ${views.toLocaleString()}</span>
            </div>

            <!-- Original Tweet -->
            <div>
              <h3 class="text-sm font-medium text-ink-500 mb-1">üìù ÂéüÊñá</h3>
              <div class="bg-cream-50 rounded-lg p-3 text-ink-800 text-sm whitespace-pre-wrap">
                ${escapeHtml(storedItem.original_text || '')}
              </div>
            </div>

            ${analysis ? `
              <!-- Translation -->
              ${analysis.translation ? `
                <div>
                  <h3 class="text-sm font-medium text-ink-500 mb-1">üåê ÁøªË≠Ø</h3>
                  <div class="bg-blue-50 rounded-lg p-3 text-ink-800 text-sm whitespace-pre-wrap">
                    ${escapeHtml(analysis.translation)}
                  </div>
                </div>
              ` : ''}

              <!-- Context Explanation -->
              ${analysis.context_explanation ? `
                <div>
                  <h3 class="text-sm font-medium text-ink-500 mb-1">üìö ËÉåÊôØË™™Êòé</h3>
                  <p class="text-sm text-ink-700">${escapeHtml(analysis.context_explanation)}</p>
                </div>
              ` : ''}

              <!-- Motivation -->
              ${analysis.motivation ? `
                <div>
                  <h3 class="text-sm font-medium text-ink-500 mb-1">üéØ ÁôºÊñáÂãïÊ©ü</h3>
                  <p class="text-sm text-ink-700">${escapeHtml(analysis.motivation)}</p>
                </div>
              ` : ''}

              <!-- Summary -->
              ${analysis.summary ? `
                <div>
                  <h3 class="text-sm font-medium text-ink-500 mb-1">üí° AI ÊëòË¶Å</h3>
                  <p class="text-sm text-ink-700">${escapeHtml(analysis.summary)}</p>
                </div>
              ` : ''}

              <!-- Title Ideas -->
              ${analysis.title_ideas?.length > 0 ? `
                <div>
                  <h3 class="text-sm font-medium text-ink-500 mb-1">‚úçÔ∏è Ê®ôÈ°åÈùàÊÑü</h3>
                  <ul class="text-sm text-ink-700 space-y-1">
                    ${analysis.title_ideas.map((t: string) => `<li class="flex items-start gap-2"><span class="text-accent">‚Ä¢</span>${escapeHtml(t)}</li>`).join('')}
                  </ul>
                </div>
              ` : ''}

              <!-- Response Angles -->
              ${analysis.angles ? `
                <div>
                  <h3 class="text-sm font-medium text-ink-500 mb-2">üîÑ ÂõûÊáâËßíÂ∫¶</h3>
                  <div class="grid md:grid-cols-2 gap-3">
                    ${analysis.angles.contrarian?.length > 0 ? `
                      <div class="bg-orange-50 rounded-lg p-3">
                        <h4 class="text-xs font-medium text-orange-700 mb-2">üî• ÂèçÂêëËßÄÈªû</h4>
                        <ul class="text-xs text-ink-700 space-y-1">
                          ${analysis.angles.contrarian.map((a: string) => `<li>‚Ä¢ ${escapeHtml(a)}</li>`).join('')}
                        </ul>
                      </div>
                    ` : ''}
                    ${analysis.angles.conventional?.length > 0 ? `
                      <div class="bg-green-50 rounded-lg p-3">
                        <h4 class="text-xs font-medium text-green-700 mb-2">‚úÖ Â∏∏Ë¶èËßÄÈªû</h4>
                        <ul class="text-xs text-ink-700 space-y-1">
                          ${analysis.angles.conventional.map((a: string) => `<li>‚Ä¢ ${escapeHtml(a)}</li>`).join('')}
                        </ul>
                      </div>
                    ` : ''}
                  </div>
                </div>
              ` : ''}

              <!-- Value Types -->
              ${analysis.value_types?.length > 0 ? `
                <div class="flex flex-wrap gap-2">
                  ${analysis.value_types.map((v: string) => `<span class="text-xs px-2 py-1 bg-purple-100 text-purple-700 rounded-full">${escapeHtml(v)}</span>`).join('')}
                </div>
              ` : ''}
            ` : `
              <div class="bg-amber-50 border border-amber-200 rounded-lg p-4">
                <p class="text-amber-800 text-sm">
                  <strong>AI ÂàÜÊûêÂ∞öÊú™Ê∫ñÂÇôÂ•Ω</strong><br>
                  Ê≠§Êé®ÊñáÁöÑ AI ÂàÜÊûêÂ∞áÂú®‰∏ãÊ¨° batch ËôïÁêÜÊôÇÁîüÊàê„ÄÇ
                </p>
              </div>
            `}
          </div>
        `;
      }

      currentAnalysis = analysis;

      // Mark X item as viewed
      if (!prefs.viewed.includes(itemId)) {
        prefs.viewed.push(itemId);
        setPrefs(prefs);
        xItem.classList.add('is-viewed');
      }

      openModal();
    }

    // Title click for analysis (using event delegation on document for dynamic content)
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;

      // Handle X item click
      const xItem = target.closest('.x-item') as HTMLElement;
      if (xItem && !target.closest('.x-external-link')) {
        e.stopPropagation();
        handleXAnalyze(xItem);
        return;
      }

      // Handle Community item title click
      const title = target.closest('.card-title');
      if (title) {
        e.stopPropagation();
        const card = title.closest('.item-card') as HTMLElement;
        if (card) handleAnalyze(card);
      }
    });

    // Modal close handlers
    modalBackdrop?.addEventListener('click', closeModal);
    modalClose?.addEventListener('click', closeModal);

    // Copy with analysis
    modalCopy?.addEventListener('click', async () => {
      if (!currentItem || !currentAnalysis) return;

      let text = '';

      if (currentItem.source === 'x') {
        // X items format
        const angles = [
          ...(currentAnalysis.angles?.contrarian || []).map((a: string) => `- üî• ${a}`),
          ...(currentAnalysis.angles?.conventional || []).map((a: string) => `- ‚úÖ ${a}`),
        ].join('\n');

        text = `## Êé®ÊñáË≥áË®ä
‰ΩúËÄÖ: ${currentItem.title.split(':')[0]}
ÈÄ£Áµê: ${currentItem.url}

## ÂéüÊñá
${currentItem.selftext || '(ÁÑ°ÂÖßÂÆπ)'}

## ÁøªË≠Ø
${currentAnalysis.translation || '(ÁÑ°ÁøªË≠Ø)'}

## AI ÂàÜÊûê
${currentAnalysis.summary || ''}

ËÉåÊôØË™™Êòé: ${currentAnalysis.context_explanation || ''}

ÁôºÊñáÂãïÊ©ü: ${currentAnalysis.motivation || ''}

${currentAnalysis.investment_signal ? `ÊäïË≥áË®äËôü: ${currentAnalysis.investment_signal}` : ''}

## ÂõûÊáâËßíÂ∫¶
${angles || '(ÁÑ°Âª∫Ë≠∞ËßíÂ∫¶)'}

## Ê®ôÈ°åÈùàÊÑü
${(currentAnalysis.title_ideas || []).map((t: string) => `- ${t}`).join('\n') || '(ÁÑ°Ê®ôÈ°åÂª∫Ë≠∞)'}

---
Ë´ãÂπ´ÊàëÈáùÂ∞çÈÄôÂâáÊé®ÊñáÊí∞ÂØ´ FB Ë≤ºÊñá/Blog ÊñáÁ´†„ÄÇ`;
      } else {
        // Community items format (Reddit, HN, PH)
        text = `## ÊñáÁ´†Ë≥áË®ä
Ê®ôÈ°å: ${currentItem.title}
‰æÜÊ∫ê: ${currentItem.source}${currentItem.subreddit ? ` (r/${currentItem.subreddit})` : currentItem.category ? ` (${currentItem.category})` : ''}
ÂàÜÊï∏: ${currentItem.score} | Ë©ïË´ñ: ${currentItem.comments}
ÈÄ£Áµê: ${currentItem.url}

## ÂéüÊñáÊëòË¶Å
${currentItem.selftext || '(ÁÑ°ÂÖßÂÆπ)'}

## AI ÂàÜÊûê
${currentAnalysis.summary_zh || ''}

ÁÇ∫‰ªÄÈ∫ºÂèóÊ≠°Ëøé: ${currentAnalysis.why_popular || ''}

ÂõûÊáâËßíÂ∫¶:
${(currentAnalysis.response_angles || []).map((a: string) => `- ${a}`).join('\n') || '(ÁÑ°Âª∫Ë≠∞ËßíÂ∫¶)'}

---
Ë´ãÂπ´ÊàëÈáùÂ∞çÈÄôÁØáÊñáÁ´†Êí∞ÂØ´ÂõûÊáâ/FB Ë≤ºÊñá/Blog ÊñáÁ´†„ÄÇ`;
      }

      try {
        await navigator.clipboard.writeText(text);
        const btn = modalCopy as HTMLButtonElement;
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => {
          btn.textContent = originalText;
        }, 1500);
      } catch (err) {
        console.error('Failed to copy:', err);
      }
    });

    // Modal Hide button - toggle behavior
    modalHide?.addEventListener('click', () => {
      if (!currentItem) return;
      const id = currentItem.id;
      const isHidden = prefs.hidden.includes(id);

      if (isHidden) {
        // Remove from hidden
        prefs.hidden = prefs.hidden.filter(h => h !== id);
        modalHide.className = 'px-3 py-2 text-sm font-medium text-red-600 hover:bg-red-50 rounded-lg transition-colors flex items-center gap-1';
        modalHide.innerHTML = '<span>üóëÔ∏è</span> Èö±Ëóè';
        // Update card visual state
        const card = container?.querySelector(`[data-id="${id}"]`);
        card?.classList.remove('is-hidden');
      } else {
        // Add to hidden
        prefs.hidden.push(id);
        modalHide.className = 'px-3 py-2 text-sm font-medium text-white bg-red-500 rounded-lg transition-colors flex items-center gap-1';
        modalHide.innerHTML = '<span>üóëÔ∏è</span> Â∑≤Èö±Ëóè';
        // Update card visual state
        const card = container?.querySelector(`[data-id="${id}"]`);
        card?.classList.add('is-hidden');
      }

      setPrefs(prefs);
      updateCounts();
      applyFilters();
    });

    // Modal Save button - toggle behavior
    modalSave?.addEventListener('click', () => {
      if (!currentItem) return;
      const id = currentItem.id;
      const isSaved = prefs.saved.includes(id);

      if (isSaved) {
        // Remove from saved
        prefs.saved = prefs.saved.filter(s => s !== id);
        modalSave.className = 'px-3 py-2 text-sm font-medium text-rose-600 hover:bg-rose-50 rounded-lg transition-colors flex items-center gap-1';
        modalSave.innerHTML = '<span>‚ô•</span> Êî∂Ëóè';
        // Update card visual state
        const card = container?.querySelector(`[data-id="${id}"]`);
        card?.classList.remove('is-saved');
      } else {
        // Add to saved
        prefs.saved.push(id);
        modalSave.className = 'px-3 py-2 text-sm font-medium text-white bg-rose-500 rounded-lg transition-colors flex items-center gap-1';
        modalSave.innerHTML = '<span>‚ô•</span> Â∑≤Êî∂Ëóè';
        // Update card visual state
        const card = container?.querySelector(`[data-id="${id}"]`);
        card?.classList.add('is-saved');
      }

      setPrefs(prefs);
      updateCounts();
    });

    // ESC to close modal
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !modal?.classList.contains('hidden')) {
        closeModal();
      }
    });
  }

  // Initialize - first load data from API, then setup UI handlers
  async function init() {
    await loadDataFromAPI();
    initPanopticon();
  }

  init();
  document.addEventListener('astro:after-swap', init);
</script>

<style>
  .item-card.is-hidden {
    opacity: 0.5;
  }
</style>
